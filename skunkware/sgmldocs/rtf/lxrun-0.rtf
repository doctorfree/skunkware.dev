{\rtf1\ansi
{\fonttbl
{\f0\fswiss Helvetica;}
{\f1\fmodern Courier;}
{\f2\froman Times;}
{\f3\froman Symbol;}
}
{\info{\comment Translated from SGML to RTF w/ Linuxdoc-SGML}}

\page{\pard\plain\keepn\f0\fs36\b\tx576{1 Introduction}}
{}#{\footnote TOC_0}

${\footnote Introduction}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote Introduction}

\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{1.1 What is lxrun ?}}
{}#{\footnote TOC_1}
{}K{\footnote What is lxrun ?}

Lxrun is an emulator that allows the execution of Intel Linux binaries on 
Intel UNIX[reg   ] platforms. The currently supported platforms are 
SCO OpenServer 5 (UNIX SVR3), SCO UnixWare 2.x (UNIX SVR4) and  
SCO UnixWare 7 (UNIX SVR5).
\par\pard\plain
\li500{}
\sb200\fi0
Lxrun works by remapping system calls on the fly. Since lxrun does its work  
at the system call level, it requires copies of the Linux dynamic loader  
(ld-linux.so.*) and whatever Linux shared libraries are required by the  
program being run. The current development release of lxrun consists of 
approximately 6000 lines of code (146 Kilobytes).
\par\pard\plain
\li500{}
\sb200\fi0
Most programs that do not rely on Linux-specific quirks 
or deal directly with hardware should work under lxrun. 
Users of lxrun have reported success with raplayer (RealAudio client), 
xquake, the StarOffice suite, gcc (the GNU C compiler), smbclient, 
the AC3D modeller and a myriad of smaller applications and utilities.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{1.2 Why should I use lxrun ?}}
{}#{\footnote TOC_2}
{}K{\footnote Why should I use lxrun ?}

The original impetus for writing lxrun was to be able to run Netscape 
Navigator 1.x on SCO OpenServer. When Netscape ported Navigator to SCO  
platforms, the need was obviated. Later, work was resumed in an attempt to  
run Adobe Acrobat Reader on OpenServer. The body of system call mappings in  
lxrun grew gradually as users modified it to work with more and more  
applications. By this process, lxrun became quite robust, able to handle  
sophisticated X11, audio, and networking applications.
\par\pard\plain
\li500{}
\sb200\fi0
Lxrun promotes the interoperability of Linux with other UNIX and 
UNIX-like platforms. This improves the user's ability to 
combine the best aspects of available operating systems. For 
example, it allows a user to combine Linux's large freeware 
application base with SCO's:
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Large robust filesystem support
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Large installed base
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Renowned and Industry-proven scalability
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Enterprise applications base
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Installed Enterprise server deployment
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Network Computer / "Any Client" deployment of applications
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Ability to distribute and execute applications via  
\url{Tarantella}
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Robust DOS/Windows '95 emulation capabilities
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} \url{Free UNIX} 
offer makes for extremely inexpensive robust UNIX workstation
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} SVR5 enhancements 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Up to 64GB of main memory 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} 1 TB File Systems and disk partitions 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} 1 TB file sizes 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Up to 76,800 TB of total storage supported 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Up to 32 CPUs supported 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Support for I2O Peripherals 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} 64-bit technology
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Advanced Clustering Support for up to 4 nodes 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Hot Pluggable Disk and Tape Drives 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Disk Mirroring and Spanning 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Hot Plug PCI 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Multi-path I/O 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Real-time Data Management 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} UPS Monitoring
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Centralized, on-line backup
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7} Journaling File Systems for improved data recovery
\par\pard\plain
\li500{}
\sb200\fi0
Every UNIX vendor could construct such a "Why you should use my 
platform" list.  Lxrun allows the user to leverage the large base 
of precompiled Linux software without restricting the choice of platform.
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{2 Implementation}}
{}#{\footnote TOC_3}

${\footnote Implementation}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote Implementation}

The emulator needed to handle the following major issues (detailed below): 
system call handling along with remapping of arguments, flags, return values 
and error codes; library pathname lookup and remapping; ioctl mappings for 
the various major devices and differences in the tty subsystems.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{2.1 Design goals}}
{}#{\footnote TOC_4}
{}K{\footnote Design goals}

\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Allow execution of Intel Linux binaries on other Intel UNIX platforms
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} Exist entirely in user-space (no kernel modifications)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} No modification of the Linux binaries or libraries required
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{2.2 Difference in syscall handling}}
{}#{\footnote TOC_5}
{}K{\footnote Difference in syscall handling}

System call handling is implemented differently between Linux and Intel 
UNIX System V platforms; that is each uses a different instruction 
to implement the switch to kernel mode.
\par\pard\plain
\li500{}
\sb200\fi0
Intel Unix System V uses a "lcall $0x07".  In Linux an "int $0x80" software 
interrupt instruction is used, which jumps to the  system-call-handling  
portion of the Linux kernel. On SCO systems, "int $0x80" is an unused vector  
and therefore causes a general protection trap resulting in a SIGSEGV 
signal. Lxrun intercepts these signals and calls the SCO equivalent of 
the system call that the Linux program attempted. In many cases this is 
a direct map or call of the equivalent native system call, in other cases 
some mapping or translation of arguments passed in and flags and error codes 
passed out is required. Where there is no equivalent system call available 
on the emulated system or the equivalent syscall mapping has not been 
implemented the system call fails and returns an errorcode of ENOSYS.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{2.3 Pathname for loading Linux libraries }}
{}#{\footnote TOC_6}
{}K{\footnote Pathname for loading Linux libraries }

Because lxrun works at the system call level, any Linux shared 
libraries required by the application must be present in the 
emulation environment.  This leads to a possible filename-space 
conflict between native and Linux binaries.  To resolve this 
problem, lxrun remaps any pathnames beginning with /lib, 
/usr/lib, /usr/local/lib, or /usr/X11R6/lib by prepending them 
with a "Linux root" path.  This path is specified at compile 
time and can be overridden by setting the LINUX[lowbar]ROOT environment 
variable. This remapping allows the user to install a set of 
Linux libraries in a separate directory hierarchy from the 
native system libraries, thus avoiding conflicts.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{2.4 Device major number mappings}}
{}#{\footnote TOC_7}
{}K{\footnote Device major number mappings}

The arguments to an ioctl call alone do not provide enough 
information to remap the command number correctly.  This is 
because the same command number can have different meanings to 
different drivers.
\par\pard\plain
\li500{}
\sb200\fi0
Lxrun works around this problem by maintaining a mapping from 
open file descriptors to drivers.  On the first ioctl call to a 
new file descriptor, lxrun determines the associated major 
device number.  It compares this with a table of drivers and 
major device numbers set up at run-time.  This mapping is then 
cached to improve performance on future ioctl calls to that file 
descriptor.  Lxrun can then take the driver into consideration 
when remapping ioctl command numbers.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{2.5 Differences in kernel tty systems}}
{}#{\footnote TOC_8}
{}K{\footnote Differences in kernel tty systems}

The following is a discourse on lxrun tty handling from Robert Lipe 
\url{(robertl@dgii.com)}, the 
principal author of lxrun's tty handling code:
\par\pard\plain
\li500{}
\sb200\fi0
"The kernel tty systems are very different. The user level tty systems 
are actually quite similar, fortunately for lxrun. Most of the members 
of things like termio and struct termios are the same size, alignment,  
and offset. Even most of the bitfields fall into place. While 
it would have been much safer to do 

\par\pard\sb200\keep\li1000{}{\f1    if ( (lx[lowbar]tio->c[lowbar]cflag & LX[lowbar]CBAUD) == LX[lowbar]B50) \line
                tio->c[lowbar]cflag |= B50; \line
        if (lx[lowbar]tio->c[lowbar]iflag & LX[lowbar]ICANON)  \line
                tio->c[lowbar]iflag |= ICANON;}\line
\par\pard\sb200\li500{} 
and repeat this for each of a couple hundred flags, the reality was that 
it generated horrible code that would have performed poorly and been 
a nightmare to maintain. 
\par\pard\plain
\li500{}
\sb200\fi0
The only sticky spot was that Linux has four distinctly separate 
members in c[lowbar]cc (the control character array) for VMIN, VTIME, EOF,  
and EOL. Most System V's including OpenServer (I can't recall what SVR[lsqb  ]45]  
does here) use the same offset and multiplex this into two bytes. In reality,  
since they can never both be active at the same time (if ICANON is set, EOF  
and EOL are used. If ICANON is clear, VMIN, VTIME are used) this doesn't turn 
out to be much of a issue.
\par\pard\plain
\li500{}
\sb200\fi0
[lsqb  ]Since] TCGETA and TCSETA are by far the most frequently used, I implemented  
them first (and their derivatives that wait and flush and the derivatives of  
each of those for POSIX struct termios). With those 8 in hand, I started firing  
up applications that were known to do wierd things to the tty. When elvis  
(the Linux vi binary I had at the time) worked well enough, I submitted the  
changes. Then, I just used more and more applications and picked up a few  
stragglers like FIONREAD that mapped very simply. 
\par\pard\plain
\li500{}
\sb200\fi0
Are there hazards in any of this? Certainly. Each system has a few 
bits in each of the available ioctls that don't exist in the other 
system. There is some overlap. We haven't seen any real world 
failures becuase of this. The reality seems to be that the programs 
that drive serial ports to the crazy edge don't make sense to emulate 
anyway. For example, someone once asked me why Linux ecu (a kermit-like 
program) didn't work well. Since source for it is available and it 
supports OpenServer just fine, use the native binary instead. Someone 
once asked me about running Linux ppp, but that's similarly nonsensical, 
though doomed to failure for different reasons."
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{2.6 Miscellaneous issues}}
{}#{\footnote TOC_9}
{}K{\footnote Miscellaneous issues}

\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  For local displays, SCO OpenServer uses ":0.0" and UnixWare uses 
"unix:0.0".  The former causes Linux X11 binaries to try to 
use shared memory, which won't work with the native X server. 
The latter causes a name lookup for the machine "unix" which 
probably fails. These two cases are detected and the DISPLAY 
is set to contain a valid machine name instead.
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  Documentation is supplied in the {\f1 doc} subdirectory of the lxrun 
source. This currently consists of this document, a FAQ, a document 
describing how to get the Linux StarOffice suite to run, and the system 
call mapping table.
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  Various packaging conveniences have been supplied. For instance, the 
necessary Linux shared libraries have been re-packaged in the native 
installation format. A shell script, lxfront, useful in the execution 
of Linux a.out and statically-linked ELF binaries, has been supplied. 
To use lxfront: 
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7}  Put lxfront and any Linux a.out or statically-linked ELF  
binaries in /usr/local/linux/bin
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7}  Put lxrun in /usr/local/bin
\par\pard\plain
\li1500{}
\sb200\fi0
\li1500{}\fi-200{\f3\'B7}  Create links in /usr/local/bin to lxfront with the same  
names as your Linux binaries.
 
Executing these links should invoke lxrun on your Linux program. 
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{3 Development Issues}}
{}#{\footnote TOC_10}

${\footnote Development_Issues}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote Development Issues}

\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{3.1 Direct execution of Linux ELF binaries}}
{}#{\footnote TOC_11}
{}K{\footnote Direct execution of Linux ELF binaries}

{}#{\footnote sec_direct}
{}K{\footnote sec_direct}


Rather than running Linux binaries with the lxrun front-end, it is possible 
to turn lxrun into a program interpreter, ld-linux.so.* - the Linux runtime  
linker. The path of the interpreter is actually embedded in every dynamic  
linked ELF executable - for standard UnixWare / OpenServer ELF it is 
/usr/lib/libc.so.1, and for Linux it is /lib/ld-linux.so.1 (or, ld-linux.so.2 
for executables linked with GNU libc v2). 
\par\pard\plain
\li500{}
\sb200\fi0
The direct execution of Linux binaries in this manner is in the latest  
development releases of lxrun. At the time of this writing, support for 
this model of execution is available on UnixWare platforms only. SCO OpenServer 
places some rather strict limitations on what a program interpreter can be. 
Overcoming these restrictions is a current development topic.
\par\pard\plain
\li500{}
\sb200\fi0
The following discourse, from Mike Davidson 
\url{(md@sco.com)} the author of lxrun,  
details some of the issues involved in the direct execution model:
\par\pard\plain
\li500{}
\sb200\fi0
"It's actually quite simple to build a version of lxrun which 
can be used as the initial program interpreter for Linux binaries. 
There are, however, a couple of problems: 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  runtime linkers are usually ELF shared objects 
which don't have a fixed load address, and which have 
to do some rather delicate data relocations when they 
first start up - I avoided this issue by making the 
ld-linux.so.* version of lxrun be an actual ELF executable 
(rather than a shared library) bound to a fixed address 
which does not conflict with the addresses used by normal 
Linux binaries - while this is a bit of a kludge it works 
perfectly well
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  the interpreter program loaded by the kernel cannot itself 
require an interpreter - what this means is that if the 
program interpreter wants to do any dynamic loading of 
shared libraries it has to do it for itself - this isn't 
too much of a problem on OpenServer since you can just 
do a static link of everything that lxrun needs into a 
single binary - unfortunately this doesn't work on UnixWare 7 
since libsocket is {\i only} available as a shared library.
 
I think that there is a way round this, but I haven't had time to 
try it out yet. Essentially it looks something like this: 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}        ld-linux.so.* is created as a dynamic linked shared object 
with appropriate dependencies on other shared libraries 
(ie at least /usr/lib/libc.so.1 and /usr/lib/libsocket.so.1)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}        when ld-linux.so.* is loaded by the kernel and gets control, 
the {\i first} thing that it does is to fix up enough of it's 
own data relocations in order to be able to run
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}        once that is done, it maps /usr/lib/libc.so.1 (ie the normal 
system runtime linker and standard library) into memory, 
fakes up a suitable aux vector and invokes the normal 
runtime linker, while pretending to be a normal executable 
program (this involves a lot of trickery - you have to fake up 
an appropriate set of program headers to give to the runtime 
linker, you have to fix up entries in .dynamic, .dynsym and 
.rel.* to reflect the actual address that ld-linux.so.* is 
actually loaded at, and you have to provide a fake entry 
point address so that the system runtime linker will give 
control back to ld-linux.so.* in the right place ....)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}        if all of that works, then ld-linux.so.* proceeds as normal, 
and now maps in the Linux runtime linker and passes control 
to it
 
I realise that this all sounds hideously complicated, but all of the 
alternatives that I can think of are worse in some way.
\par\pard\plain
\li500{}
\sb200\fi0
At first I thought that we could avoid this by just porting a 
version of the Linux runtime linker to run native on UNIX, but 
this looks like it may be more trouble than it is worth - while 
the Linux runtime linker is quite well written it has to deal 
with some rather unpleasant limitations in the GNU tools - in 
particular it looks as if GNU ld doesn't support the equivalent 
of our -Bsymbolic option which makes writing the startup code 
for a runtime linker almost impossible (in fact the Linux runtime 
linker startup routine is just one massive function that uses 
nothing but local variables and which does all of it's system 
calls with chunks of inline assembler)."
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{3.2 SIGSEGV vs. software interrupt kernel module}}
{}#{\footnote TOC_12}
{}K{\footnote SIGSEGV vs. software interrupt kernel module}

Consideration was given to implementing a software interrupt kernel module 
rather than relying on the "int $0x80" segmentation violation. Rather than 
sacrifice the elegance and portability of a "non-kernel" Linux emulation 
strategy, Mike Davidson has suggested that: 
\begin{quotation}
This probably isn't really necessary. Assuming that we are really 
only interested in Linux ELF (and {\i not} Linux a.out) we can use 
the dynamic linker to "preload" the Linux runtime compatibility 
library in such a way that almost all of the system calls will be 
intercepted and handled directly by the compatibility library  
without ever going down to an actual "int $0x80" instruction.
\end{quotation}
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{3.3 Performance enhancements}}
{}#{\footnote TOC_13}
{}K{\footnote Performance enhancements}

Thus far, performance has not been an issue as very little negative 
impact has been detected.  The main cost of running a Linux application under 
lxrun is the overhead of catching the segmentation violation (int $0x80), 
fixing up the structures/errors/returns, and mapping the system call. 
Since much of what lxrun does is done in the normal course of executing a  
system call natively, the SIGSEGV intercept is the main overhead.
\par\pard\plain
\li500{}
\sb200\fi0
In order to avoid catching SIGSEGV for every system call, current lxrun 
development plans on implementing a "pre-load" of the "Linux runtime  
compatibility library" (see the previous subsection). With the direct  
execution of Linux ELF binaries described above, it is possible to pre-load  
this library on startup. That is, the binary has already 
been identified as a Linux ELF binary since it is attempting to load 
/lib/ld-linux.so.1. This "fake" program interpreter knows it will have to 
map system calls so, rather than waiting for the SIGSEGV to trigger the  
mapping, the program interpreter can "pre-map". Thus, system calls made by 
the Linux ELF binary under the control of such a program interpreter would 
not cause general protection traps. In this scenario, nearly all of the  
performance overhead of running Linux binaries with lxrun is eliminated.
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{4 System Call Mapping}}
{}#{\footnote TOC_14}

${\footnote System_Call_Mapping}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote System Call Mapping}

Lxrun emulates or maps most commonly-used system calls for which native  
equivalents exist. Unimplemented calls return an error indication and set  
ENOSYS.
\par\pard\plain
\li500{}
\sb200\fi0
The files doc/SysCallTable* list tables of supported, partially supported,  
and unsupported system calls. The SyscallScript utility run (against the  
source) will regenerate the text and HTML versions of this file. An on-line  
copy of the currently supported system calls is available at  
\url{urlnam}.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{4.1 Directly mapped system calls}}
{}#{\footnote TOC_15}
{}K{\footnote Directly mapped system calls}

The following system calls are mapped directly:
\par\pard\plain
\li500{}
\sb200\fi0
{\i exit() fork() creat() link() unlink() chdir() time() mknod() chmod() chown()  
lseek() getpid() setuid() 
getuid() stime() alarm() pause() utime() access() nice() sync() rename()  
mkdir() rmdir() dup() times() 
setgid() getgid() geteuid() getegid() setpgid() umask() chroot() dup2()  
getppid() getpgrp() setsid() 
setreuid() setregid() sethostname() gettimeofday() settimeofday() symlink()  
readlink() 
truncate() ftruncate() fchmod() fchown() setitimer() getitimer() fsync()  
setdomainname() 
getpgid() fchdir() sysfs() getdents() readv() writev() getsid()}
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{4.2 System calls with a non-stub emulation function}}
{}#{\footnote TOC_16}
{}K{\footnote System calls with a non-stub emulation function}

For the following system calls, lxrun either provides some 
remapping of arguments, return values, and error codes, or in 
cases where an analogous native call does not exist, emulates 
the call using native library functions.
\par\pard\plain
\li500{}
\sb200\fi0
{\i nosys() read() write() open() close() waitpid() execve() oldstat() ptrace()  
oldfstat() kill() pipe() 
brk() signal() fcntl() olduname() sigaction() sgetmask() ssetmask()  
sigsuspend() sigpending() 
setrlimit() getrlimit() getgroups() setgroups() old[lowbar]select() oldlstat()  
uselib() 
readdir() mmap() munmap() getpriority() setpriority() socketcall() syslog()  
stat() lstat() 
fstat() uname() iopl() wait4() sysinfo() ipc() sigreturn() newuname()  
mprotect() sigprocmask() 
personality() [lowbar]llseek() select()}
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{4.3 Partial implementations}}
{}#{\footnote TOC_17}
{}K{\footnote Partial implementations}

The following system calls are partially emulated:
\par\pard\plain
\li500{}
\sb200\fi0
{\i ioctl() ioperm() fdatasync()}
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{4.4 Unimplemented system calls}}
{}#{\footnote TOC_18}
{}K{\footnote Unimplemented system calls}

The list of unimplemented system calls is as follows:
\par\pard\plain
\li500{}
\sb200\fi0
{\i mount() umount() getrusage() swapon() reboot() statfs() fstatfs() vhangup()  
idle() vm86() swapoff() 
clone() modify[lowbar]ldt() adjtimex() create[lowbar]module()  
init[lowbar]module() 
delete[lowbar]module() get[lowbar]kernel[lowbar]syms() quotactl() bdflush()  
setfsuid() 
setfsgid() flock() msync() sysctl() mlock() munlock() mlockall() munlockall() 
sched[lowbar]setparam() sched[lowbar]getparam() sched[lowbar]setscheduler() 
sched[lowbar]getscheduler() sched[lowbar]yield() 
sched[lowbar]get[lowbar]priority[lowbar]max() 
sched[lowbar]get[lowbar]priority[lowbar]min() 
sched[lowbar]rr[lowbar]get[lowbar]interval()}
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{5 Getting started}}
{}#{\footnote TOC_19}

${\footnote Getting_started}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote Getting started}

\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{5.1 How do I get lxrun ?}}
{}#{\footnote TOC_20}
{}K{\footnote How do I get lxrun ?}

Lxrun is currently distributed as a component of {\b SCO Skunkware} 
\url{urlnam}, 
a free CD-ROM containing hundreds of megabytes of pre-compiled and pre-packaged  
software for SCO platforms. A Skunkware CD-ROM can be obtained via 
\url{urlnam} and, beginning in 1998, all operating 
systems released by SCO will contain a Skunkware CD-ROM in the shrink-wrapped 
product. Lxrun may also be obtained via the SCO Skunkware web site at  
\url{urlnam}. 
All SCO Skunkware software is freely redistributable.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{5.2 Building lxrun from source}}
{}#{\footnote TOC_21}
{}K{\footnote Building lxrun from source}

Detailed instructions on building lxrun from source, configuring the build,  
installing the emulation system and additional run-time components, installing  
a Linux binary, runtime environment variables, and error messages are contained 
in the file {\f1 INSTALL} in the lxrun source distribution and on-line in 
\url{the lxrun FAQ}.
\par\pard\plain
\li500{}
\sb200\fi0
The lxrun source distribution contains a Makefile with support for compilation 
on SCO OpenServer 5, UnixWare 2.x, and UnixWare 7. The Makefile uses the 
output of "uname -r" to determine the platform. As additional 
platform support is added this will need to be augmented or the configuration 
modified to use autoconfig.
\par\pard\plain
\li500{}
\sb200\fi0
To build lxrun on one of the supported platforms, it is only necessary to 
issue the command "make". The command "make install" will both build lxrun 
and copy the resulting binaries and documentation into $(DESTDIR) which 
is set by default to the ./dist directory.
\par\pard\plain
\li500{}
\sb200\fi0
As a convenience this distribution includes a script called  
lxfront which can be used with a symbolic link (see below) to provide  
a wrapper around the invocation of lxrun the Linux binary name 
allowing them to be run directly.
\par\pard\plain
\li500{}
\sb200\fi0
Starting with lxrun 0.9.0 the build of lxrun will produce an ld-linux.so.1 
as well as the lxrun binary. The ld-linux.so.1 is installed in /lib on the 
target system and provides support for direct execution of Linux binaries, 
thus deprecating the need for the lxrun binary front-end except for the 
execution of Linux a.out binaries.
\par\pard\plain
\li500{}
\sb200\fi0
The lxrun source has the following capability ifdefs: 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b DEF[lowbar]LINUX[lowbar]ROOT} - 
Default root directory name for lxrun to searching under for any 
native Linux files.  
Specifically when a Linux library tries to load a dynamic library, lxrun 
remaps the pathname to somewhere below this directory.   
The value specified here becomes the internal default which can be  
overridden by the LINUX[lowbar]ROOT environment variable. 
Set in Makefile with make macro LXROOT. 
Default value is "/usr/local/linux"
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b TRACE} - 
Flag for making a version of lxrun that emits system call traces  
(to file /tmp/lxrun.nnn (where "nnn" is the process pid.)) 
This can be used for tracing a binaries use of an unimplemented  
system call or other runtime problems. Its not enabled bu default  
since it slows down the operation of lxrun and produces large log files. 
(build should be augmented to make a variantly named lxrun binary with this  
on regardless). 
Set in Makefile with make macro TRACE. 
Default is disabled (off)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b ELF[lowbar]DEBUG} - 
Flag to enable output to stderr of debug traces for the  
ELF loader capability of lxrun. Outputs ELF Header information, 
interpreter remap values and open, load, mmap, mprotect values/status 
(should be modified to be integrated with TRACE logging) 
Set in Makefile via make macro DBG. 
Default is disabled (off)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b UNIDIRECTIONAL[lowbar]PIPES} - 
Flag to enable use of unidirectional pipes (pipe() )  
instead of bidirectional pipes (socketpair()) for the pipe() 
syscall emulation on platforms where pipes are not bidirectional. 
Not referenced in Makefile. 
Default is disabled (emulation will use bidirectional pipes)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b NO[lowbar]DISPLAY[lowbar]HACK} - 
Flag to disable remapping of DISPLAY variable from a local server  
specification to a full hostname specification. 
This remapping is done (by default) to address some  
problems with local connections on OSr5 (at least) to some X servers. 
Not referenced in Makefile. 
Default is disabled (remapping will be done)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b LXRUN[lowbar]AUTO[lowbar]PATH[lowbar]BEHAVIOR} - 
if enabled makes lxrun search for the Linux binary to be run in the  
normal PATH rather than in the (expected) absolute pathname given. 
Not referenced in Makefile. 
Default is disabled (off)
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7} {\b ELFMARK[lowbar]HACK} - 
enables detection of binaries marked (with elfmark) as Linux binaries 
(mark value "LXRN" as an unsigned long). 
Not referenced in Makefile. 
Default is disabled (off) - status is experimental.
\par\pard\plain
\li500{}
\sb200\fi0
Platform defines for OpenServer 5 (OSR5), UnixWare 2.x (UNIXWARE)  
and UnixWare 7 (GEMINI) are automatically setup in the Makefile.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{5.3 Installing the emulation system}}
{}#{\footnote TOC_22}
{}K{\footnote Installing the emulation system}

Lxrun expects to find all its (Linux) library files in a normal root hierarchy 
rooted under a single place called the LINUX[lowbar]ROOT. 
Unless respecified in the build this defaults internally in lxrun to 
/usr/local/linux.
\par\pard\plain
\li500{}
\sb200\fi0
You can respecify or change it at runtime with the environment variable 
LINUX[lowbar]ROOT (wherever it ends up this must be the place the Linux  
libraries are placed under).
\par\pard\plain
\li500{}
\sb200\fi0
"make install" will install the built binary (lxrun) into /usr/local/bin, 
lxfront into $LINUX[lowbar]ROOT/bin, and the lxrun program interpreter 
ld-linux.so.1 into /lib. The HTML documents describing lxrun are placed 
in /usr/local/man/html/lxrun.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{5.4 Installing Linux applications}}
{}#{\footnote TOC_23}
{}K{\footnote Installing Linux applications}

\par\pard\plain
\li500{}
\sb200\fi0
With lxrun 0.9.0 and later, Linux ELF binaries can be installed anywhere in 
the standard execution path (e.g. /usr/local/bin). See section 
{\uldb Direct execution of Linux ELF binaries}{\v sec-direct} 
for details on how this is done. Further, Linux applications distributed in  
RPM format can be installed using either a native RPM port  
or the Linux RPM run under the control of lxrun. Some additional arguments 
to RPM may be necessary. For instance, a native port of RPM for SCO OpenServer  
is available at \url{urlnam}). 
Using the SCO OpenServer RPM it is necessary to invoke RPM as follows: 

\par\pard\sb200\keep\li1000{}{\f1     rpm --nodeps --ignorearch --ignoreos --prefix /usr/local ...}\line
\par\pard\sb200\li500{} 
The Skunkware distribution of RPM for OpenServer includes a shell script 
front-end {\f1 rpm4sco} which inserts these arguments for you.
\par\pard\plain
\li500{}
\sb200\fi0
Linux a.out and statically linked ELF binaries should be installed in  
/usr/local/linux/bin and symbolic links by the name of the binary created  
from /usr/local/bin to the lxfront shell script in /usr/local/linux/bin.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{5.5 Error messages}}
{}#{\footnote TOC_24}
{}K{\footnote Error messages}

{\f1 linuxemul: fatal error: program load failed: No such file or directory}
\par\pard\plain
\li500{}
\sb200\fi0
Indicates that the Linux binary couldn't run  
(either lxrun could't find the Linux binary or the Linux binary  
couldn't find the dynamic linker) 
It probably means your LINUX[lowbar]ROOT environment variable isn't set up  
correctly or you don't have the required minimum Linux libraries.
\par\pard\plain
\li500{}
\sb200\fi0
{\f1 progname: can't load library 'some[lowbar]library[lowbar]name.so'}
\par\pard\plain
\li500{}
\sb200\fi0
Indicates you're missing a shared library that is needed to 
run a particular binary.  You can either try to find a 
compiled version of the library from a Linux ftp site 
(such as \url{urlnam}) or if you 
have access to a running Linux system, you can copy the 
library directly.  You should put the library in 
$LINUX[lowbar]ROOT/lib on your host system  
(/usr/localLinuxlib by default on a SCO system ).
\par\pard\plain
\li500{}
\sb200\fi0
{\f1 myprog: can't resolve symbol '[lowbar][lowbar]iob'\\  
myprog: can't resolve symbol '[lowbar][lowbar]iob'\\  
myprog: can't resolve symbol '[lowbar][lowbar]ctype'}
\par\pard\plain
\li500{}
\sb200\fi0
Indicates that the Linux dynamic loader found a native SCO library 
and is using it instead of the corresponding Linux binary.   
(You can find out exactly which library is causing the problem by 
examining the lxrun.log file produced by a debugging version of 
lxrun.)
\par\pard\plain
\li500{}
\sb200\fi0
This will only occur if you have native libraries 
installed that have the same names as a dependant Linux binary. 
If you have XFree86 installed, the /usr/X11R6/lib libraries are 
common culprits.
\par\pard\plain
\li500{}
\sb200\fi0
The best solution is to make sure no native libraries are 
available anywhere under the directory pointed to by 
$LINUX[lowbar]ROOT.
\par\pard\plain
\li500{}
\sb200\fi0

{\pard\sb200\plain\f0\fs24\b\tx576{5.6 If you come across an unsupported binary}}
{}#{\footnote TOC_25}
{}K{\footnote If you come across an unsupported binary}

\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  Go to \url{urlnam} and make 
sure you have the most recent version of lxrun.  If not, 
download the latest one and try it.  We are updating 
lxrun with new system calls all the time. 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  Recompile lxrun with the TRACE option enabled.  (This 
requires modifying one line in the Makefile.)  This will 
cause lxrun to produce a history of all system calls 
used by the binary as it was run (similar to the 
"truss" and "trace" commands).  The trace dump will be 
created in a file called "/tmp/lxrun.nnn" where "nnn" is 
the process id. 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  Try to narrow down exactly which system call failed. 
Most likely, the failure will be due to a system call 
that has not yet been implemented in lxrun. 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  Implement the system call mapping.  This is usually 
pretty easy to do.  The vast majority of lxrun's code 
does mappings of this sort, so you can pick out almost 
any source file to see how it is done.  Chances are, the 
system call you need to remap is already in one of the 
lxrun source files, but its code looks something like 
this: 

int lx[lowbar]flock()          [lcub  ] errno=ENOSYS; return -1; [rcub  ]     

This means that you're the first person who has gotten 
around to mapping that particular system call. 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  After making your modification, recompile lxrun and 
see if it works.  You may have to remap more than one 
system call to get your binary working! 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  E-mail your changes to  
\url{skunkware@sco.com}. 
This way, we can put your changes into the next release of lxrun. 
\par\pard\plain
\li1000{}
\sb200\fi0
\li1000{}\fi-200{\f3\'B7}  If steps 1-5 seem beyond your programming 
ability, contact  
\url{skunkware@sco.com}. 
and maybe one of the 
Skunkware team will have time to give you a hand with it. 
Make sure to tell us exactly what program you're having 
trouble with, and if possible, tell us where you got it.
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{6 Web Presence}}
{}#{\footnote TOC_26}

${\footnote Web_Presence}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote Web Presence}

The lxrun web site is at  
\url{urlnam}. 
Lxrun source is available at 
\url{urlnam}.
\par\pard\plain
\li500{}
\sb200\fi0
Any source changes made (augmentation or bug fixes) doc changes 
feature requests, questions or problem reports should be mailed to  
\url{skunkware@sco.com}
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{7 Authors and Contributors}}
{}#{\footnote TOC_27}

${\footnote Authors_and_Contributors}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote Authors and Contributors}

The original author of lxrun was Michael Davidson, an engineer at SCO. 
Major initial followup work was done by Robert Lipe and Steve Ginzburg. 
Andrew Gallatin ported it to Solaris/x86 and the rest of the cast includes 
Bela Lubkin, John W. Temples, Mike Hopkirk, Ralf Gelfand,  
Ronald Joe Record and Udo Monk.
\par\pard\plain
\li500{}
\sb200\fi0
Contributors to this document included Michael Davidson, Michael Hopkirk, 
Robert Lipe, Steve Ginzburg and the principal author - Ronald Record.
\par\pard\plain
\li500{}
\sb200\fi0

\page{\pard\plain\keepn\f0\fs36\b\tx576{8 About This Document}}
{}#{\footnote TOC_28}

${\footnote About_This_Document}
+{\footnote browse}
\par\pard\plain\li500\sb200\fi0
{}K{\footnote About This Document}

This document was created using SGML-Tools 1.0.6 in conjunction with TeX,  
Version 3.14159 (Web2C 7.2) running on an SCO UnixWare 7 platform. 
\par\pard\plain
\li500{}
\sb200\fi0
The source to this document is maintained at 
\url{urlnam}. 
A Makefile and formatted varieties of this document are also available at 
\url{urlnam}. For instance, 
you will find a postscript version at 
\url{urlnam}.
\par\pard\plain
\li500{}
\sb200\fi0
This document is Copyright (C) 1998 by Ronald Joe Record. 
All rights reserved. Permission to use, copy, and distribute this  
document for any purpose and without fee is hereby granted, provided  
that the above copyright notice appear in all copies and that both that  
copyright notice and this permission notice appear in supporting documentation.
\par\pard\plain
\li500{}
\sb200\fi0
}