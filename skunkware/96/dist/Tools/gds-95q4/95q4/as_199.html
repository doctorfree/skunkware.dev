<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from as.texinfo on 5 October 1995 -->

<TITLE>Using as - i386-Syntax</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="as_1.html">first</A>, <A HREF="as_198.html">previous</A>, <A HREF="as_200.html">next</A>, <A HREF="as_222.html">last</A> section, <A HREF="as_toc.html">table of contents</A>.
<HR>
<H2><A NAME="SEC201" HREF="as_toc.html#TOC201">AT&#38;T Syntax versus Intel Syntax</A></H2>
<A NAME="IDX641"></A>
<A NAME="IDX642"></A>
<P>
In order to maintain compatibility with the output of <CODE>gcc</CODE>,
<CODE>as</CODE> supports AT&#38;T System V/386 assembler syntax.  This is quite
different from Intel syntax.  We mention these differences because
almost all 80386 documents used only Intel syntax.  Notable differences
between the two syntaxes are:
<A NAME="IDX643"></A>
<A NAME="IDX644"></A>
<A NAME="IDX645"></A>
<A NAME="IDX646"></A>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>
<A NAME="IDX649"></A>
<P>
<UL>
<LI>
AT&#38;T immediate operands are preceded by <SAMP>`$'</SAMP>; Intel immediate
operands are undelimited (Intel <SAMP>`push 4'</SAMP> is AT&#38;T <SAMP>`pushl $4'</SAMP>).
AT&#38;T register operands are preceded by <SAMP>`%'</SAMP>; Intel register operands
are undelimited.  AT&#38;T absolute (as opposed to PC relative) jump/call
operands are prefixed by <SAMP>`*'</SAMP>; they are undelimited in Intel syntax.

<A NAME="IDX651"></A>
<A NAME="IDX650"></A>
<LI>
AT&#38;T and Intel syntax use the opposite order for source and destination
operands.  Intel <SAMP>`add eax, 4'</SAMP> is <SAMP>`addl $4, %eax'</SAMP>.  The
<SAMP>`source, dest'</SAMP> convention is maintained for compatibility with
previous Unix assemblers.

<A NAME="IDX653"></A>
<A NAME="IDX654"></A>
<A NAME="IDX652"></A>
<LI>
In AT&#38;T syntax the size of memory operands is determined from the last
character of the opcode name.  Opcode suffixes of <SAMP>`b'</SAMP>, <SAMP>`w'</SAMP>,
and <SAMP>`l'</SAMP> specify byte (8-bit), word (16-bit), and long (32-bit)
memory references.  Intel syntax accomplishes this by prefixes memory
operands (<EM>not</EM> the opcodes themselves) with <SAMP>`byte ptr'</SAMP>,
<SAMP>`word ptr'</SAMP>, and <SAMP>`dword ptr'</SAMP>.  Thus, Intel <SAMP>`mov al, byte
ptr <VAR>foo</VAR>'</SAMP> is <SAMP>`movb <VAR>foo</VAR>, %al'</SAMP> in AT&#38;T syntax.

<A NAME="IDX656"></A>
<A NAME="IDX655"></A>
<LI>
Immediate form long jumps and calls are
<SAMP>`lcall/ljmp $<VAR>section</VAR>, $<VAR>offset</VAR>'</SAMP> in AT&#38;T syntax; the
Intel syntax is
<SAMP>`call/jmp far <VAR>section</VAR>:<VAR>offset</VAR>'</SAMP>.  Also, the far return
instruction
is <SAMP>`lret $<VAR>stack-adjust</VAR>'</SAMP> in AT&#38;T syntax; Intel syntax is
<SAMP>`ret far <VAR>stack-adjust</VAR>'</SAMP>.

<A NAME="IDX658"></A>
<A NAME="IDX657"></A>
<LI>
The AT&#38;T assembler does not provide support for multiple section
programs.  Unix style systems expect all programs to be single sections.
</UL>
<P>
<HR>
Go to the <A HREF="as_1.html">first</A>, <A HREF="as_198.html">previous</A>, <A HREF="as_200.html">next</A>, <A HREF="as_222.html">last</A> section, <A HREF="as_toc.html">table of contents</A>.
</BODY>
</HTML>
