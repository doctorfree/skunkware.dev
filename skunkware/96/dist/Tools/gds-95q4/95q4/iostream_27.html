<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from iostream.texi on 9 October 1995 -->

<TITLE>The GNU C++ Iostream Library - Areas</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="iostream_1.html">first</A>, <A HREF="iostream_26.html">previous</A>, <A HREF="iostream_28.html">next</A>, <A HREF="iostream_35.html">last</A> section, <A HREF="iostream_toc.html">table of contents</A>.
<HR>
<H2><A NAME="SEC27" HREF="iostream_toc.html#TOC27">Areas of a <CODE>streambuf</CODE></A></H2>
<P>
Streambuf buffer management is fairly sophisticated (this is a
nice way to say "complicated").  The standard protocol
has the following "areas":
<P>
<UL>
<A NAME="IDX165"></A>
<LI>
The <DFN>put area</DFN> contains characters waiting for output.

<A NAME="IDX166"></A>
<LI>
The <DFN>get area</DFN> contains characters available for reading.
</UL>
<P>
The GNU <CODE>streambuf</CODE> design extends this, but the details are
still evolving.
<P>
The following methods are used to manipulate these areas.
These are all protected methods, which are intended to be
used by virtual function in classes derived from <CODE>streambuf</CODE>.
They are also all ANSI/ISO-standard, and the ugly names
are traditional.
(Note that if a pointer points to the 'end' of an area,
it means that it points to the character after the area.)
<P>
<A NAME="IDX167"></A>
<U>Method:</U> char* <B>streambuf::pbase</B> <I>() const</I><P>
Returns a pointer to the start of the put area.
<P>
<A NAME="IDX168"></A>
<U>Method:</U> char* <B>streambuf::epptr</B> <I>() const</I><P>
Returns a pointer to the end of the put area.
<P>
<A NAME="IDX169"></A>
<U>Method:</U> char* <B>streambuf::pptr</B> <I>() const</I><P>
If <CODE>pptr() &#60; epptr ()</CODE>, the <CODE>pptr()</CODE>
returns a pointer to the current put position.
(In that case, the next write will
overwrite <CODE>*pptr()</CODE>, and increment <CODE>pptr()</CODE>.)
Otherwise, there is no put position available
(and the next character written will cause <CODE>streambuf::overflow</CODE>
to be called).
<P>
<A NAME="IDX170"></A>
<U>Method:</U> void <B>streambuf::pbump</B> <I>(int <VAR>N</VAR>)</I><P>
Add <VAR>N</VAR> to the current put pointer.
No error checking is done.
<P>
<A NAME="IDX171"></A>
<U>Method:</U> void <B>streambuf::setp</B> <I>(char* <VAR>P</VAR>, char* <VAR>E</VAR>)</I><P>
Sets the start of the put area to <VAR>P</VAR>, the end of the put area to <VAR>E</VAR>,
and the current put pointer to <VAR>P</VAR> (also).
<P>
<A NAME="IDX172"></A>
<U>Method:</U> char* <B>streambuf::eback</B> <I>() const</I><P>
Returns a pointer to the start of the get area.
<P>
<A NAME="IDX173"></A>
<U>Method:</U> char* <B>streambuf::egptr</B> <I>() const</I><P>
Returns a pointer to the end of the get area.
<P>
<A NAME="IDX174"></A>
<U>Method:</U> char* <B>streambuf::gptr</B> <I>() const</I><P>
If <CODE>gptr() &#60; egptr ()</CODE>, then <CODE>gptr()</CODE>
returns a pointer to the current get position.
(In that case the next read will read <CODE>*gptr()</CODE>,
and possibly increment <CODE>gptr()</CODE>.)
Otherwise, there is no read position available
(and the next read will cause <CODE>streambuf::underflow</CODE>
to be called).
<P>
<A NAME="IDX175"></A>
<U>Method:</U> void <B>streambuf:gbump</B> <I>(int <VAR>N</VAR>)</I><P>
Add <VAR>N</VAR> to the current get pointer.
No error checking is done.
<P>
<A NAME="IDX176"></A>
<U>Method:</U> void <B>streambuf::setg</B> <I>(char* <VAR>B</VAR>, char* <VAR>P</VAR>, char* <VAR>E</VAR>)</I><P>
Sets the start of the get area to <VAR>B</VAR>, the end of the get area to <VAR>E</VAR>,
and the current put pointer to <VAR>P</VAR>.
<P>
<HR>
Go to the <A HREF="iostream_1.html">first</A>, <A HREF="iostream_26.html">previous</A>, <A HREF="iostream_28.html">next</A>, <A HREF="iostream_35.html">last</A> section, <A HREF="iostream_toc.html">table of contents</A>.
</BODY>
</HTML>
