<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from usegcc.texi on 9 October 1995 -->

<TITLE>Using GNU CC - Static Definitions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="usegcc_1.html">first</A>, <A HREF="usegcc_123.html">previous</A>, <A HREF="usegcc_125.html">next</A>, <A HREF="usegcc_139.html">last</A> section, <A HREF="usegcc_toc.html">table of contents</A>.
<HR>
<H3><A NAME="SEC127" HREF="usegcc_toc.html#TOC127">Declare <EM>and</EM> Define Static Members</A></H3>
<A NAME="IDX534"></A>
<A NAME="IDX535"></A>
<A NAME="IDX536"></A>
<A NAME="IDX537"></A>
<P>
When a class has static data members, it is not enough to <EM>declare</EM>
the static member; you must also <EM>define</EM> it.  For example:
<P>
<PRE>
class Foo
{
  ...
  void method();
  static int bar;
};
</PRE>
<P>
This declaration only establishes that the class <CODE>Foo</CODE> has an
<CODE>int</CODE> named <CODE>Foo::bar</CODE>, and a member function named
<CODE>Foo::method</CODE>.  But you still need to define <EM>both</EM>
<CODE>method</CODE> and <CODE>bar</CODE> elsewhere.  According to the draft ANSI
standard, you must supply an initializer in one (and only one) source
file, such as:
<P>
<PRE>
int Foo::bar = 0;
</PRE>
<P>
Other C++ compilers may not correctly implement the standard behavior.
As a result, when you switch to <CODE>g++</CODE> from one of these compilers,
you may discover that a program that appeared to work correctly in fact
does not conform to the standard: <CODE>g++</CODE> reports as undefined
symbols any static data members that lack definitions.
<P>
<HR>
Go to the <A HREF="usegcc_1.html">first</A>, <A HREF="usegcc_123.html">previous</A>, <A HREF="usegcc_125.html">next</A>, <A HREF="usegcc_139.html">last</A> section, <A HREF="usegcc_toc.html">table of contents</A>.
</BODY>
</HTML>
