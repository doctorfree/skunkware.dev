<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from libc.texinfo on 9 October 1995 -->

<TITLE>The Cygnus C Support Library - Reentrant Syscalls</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_128.html">previous</A>, <A HREF="libc_130.html">next</A>, <A HREF="libc_140.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<HR>
<H2><A NAME="SEC129" HREF="libc_toc.html#TOC129">Reentrant covers for OS subroutines</A></H2>
<P>
Since the system subroutines are used by other library routines that
require reentrancy, <TT>`libc.a'</TT> provides cover routines (for example,
the reentrant version of <CODE>fork</CODE> is <CODE>_fork_r</CODE>).  These cover
routines are consistent with the other reentrant subroutines in this
library, and achieve reentrancy by using a reserved global data block
(see section <A HREF="libc_126.html#SEC126">Reentrancy</A>).
<P>
<DL COMPACT>
<A NAME="IDX201"></A>
<DT><CODE>_open_r</CODE>
<DD>A reentrant version of <CODE>open</CODE>.  It takes a pointer
to the global data block, which holds <CODE>errno</CODE>.

<PRE>
int _open_r(void *<VAR>reent</VAR>,
    const char *<VAR>file</VAR>, int <VAR>flags</VAR>, int <VAR>mode</VAR>);
</PRE>

<A NAME="IDX202"></A>
<DT><CODE>_close_r</CODE>
<DD>A reentrant version of <CODE>close</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _close_r(void *<VAR>reent</VAR>, int <VAR>fd</VAR>);
</PRE>

<A NAME="IDX203"></A>
<DT><CODE>_lseek_r</CODE>
<DD>A reentrant version of <CODE>lseek</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
off_t _lseek_r(void *<VAR>reent</VAR>,
    int <VAR>fd</VAR>, off_t <VAR>pos</VAR>, int <VAR>whence</VAR>);
</PRE>

<A NAME="IDX204"></A>
<DT><CODE>_read_r</CODE>
<DD>A reentrant version of <CODE>read</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
long _read_r(void *<VAR>reent</VAR>,
    int <VAR>fd</VAR>, void *<VAR>buf</VAR>, size_t <VAR>cnt</VAR>);
</PRE>

<A NAME="IDX205"></A>
<DT><CODE>_write_r</CODE>
<DD>A reentrant version of <CODE>write</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
long _write_r(void *<VAR>reent</VAR>,
    int <VAR>fd</VAR>, const void *<VAR>buf</VAR>, size_t <VAR>cnt</VAR>);
</PRE>

<A NAME="IDX206"></A>
<DT><CODE>_fork_r</CODE>
<DD>A reentrant version of <CODE>fork</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _fork_r(void *<VAR>reent</VAR>);
</PRE>

<A NAME="IDX207"></A>
<DT><CODE>_wait_r</CODE>
<DD>A reentrant version of <CODE>wait</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _wait_r(void *<VAR>reent</VAR>, int *<VAR>status</VAR>);
</PRE>

<A NAME="IDX208"></A>
<DT><CODE>_stat_r</CODE>
<DD>A reentrant version of <CODE>stat</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _stat_r(void *<VAR>reent</VAR>,
    const char *<VAR>file</VAR>, struct stat *<VAR>pstat</VAR>);
</PRE>

<A NAME="IDX209"></A>
<DT><CODE>_fstat_r</CODE>
<DD>A reentrant version of <CODE>fstat</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _fstat_r(void *<VAR>reent</VAR>,
    int <VAR>fd</VAR>, struct stat *<VAR>pstat</VAR>);
</PRE>

<A NAME="IDX210"></A>
<DT><CODE>_link_r</CODE>
<DD>A reentrant version of <CODE>link</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _link_r(void *<VAR>reent</VAR>,
    const char *<VAR>old</VAR>, const char *<VAR>new</VAR>);
</PRE>

<A NAME="IDX211"></A>
<DT><CODE>_unlink_r</CODE>
<DD>A reentrant version of <CODE>unlink</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
int _unlink_r(void *<VAR>reent</VAR>, const char *<VAR>file</VAR>);
</PRE>

<A NAME="IDX212"></A>
<DT><CODE>_sbrk_r</CODE>
<DD>A reentrant version of <CODE>sbrk</CODE>.  It takes a pointer to the global
data block, which holds <CODE>errno</CODE>.

<PRE>
char *_sbrk_r(void *<VAR>reent</VAR>, size_t <VAR>incr</VAR>);
</PRE>
</DL>
<P>
<HR>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_128.html">previous</A>, <A HREF="libc_130.html">next</A>, <A HREF="libc_140.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
