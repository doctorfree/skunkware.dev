<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from usegcc.texi on 9 October 1995 -->

<TITLE>Using GNU CC - VMS Misc</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="usegcc_1.html">first</A>, <A HREF="usegcc_137.html">previous</A>, <A HREF="usegcc_139.html">next</A>, <A HREF="usegcc_139.html">last</A> section, <A HREF="usegcc_toc.html">table of contents</A>.
<HR>
<H2><A NAME="SEC141" HREF="usegcc_toc.html#TOC141">Other VMS Issues</A></H2>
<A NAME="IDX570"></A>
<A NAME="IDX571"></A>
<A NAME="IDX572"></A>
<P>
GNU CC automatically arranges for <CODE>main</CODE> to return 1 by default if
you fail to specify an explicit return value.  This will be interpreted
by VMS as a status code indicating a normal successful completion.
Version 1 of GNU CC did not provide this default.
<P>
GNU CC on VMS works only with the GNU assembler, GAS.  You need version
1.37 or later of GAS in order to produce value debugging information for
the VMS debugger.  Use the ordinary VMS linker with the object files
produced by GAS.
<A NAME="IDX573"></A>
<A NAME="IDX574"></A>
<P>
Under previous versions of GNU CC, the generated code would occasionally
give strange results when linked to the sharable <TT>`VAXCRTL'</TT> library.
Now this should work.
<P>
A caveat for use of <CODE>const</CODE> global variables: the <CODE>const</CODE>
modifier must be specified in every external declaration of the variable
in all of the source files that use that variable.  Otherwise the linker
will issue warnings about conflicting attributes for the variable.  Your
program will still work despite the warnings, but the variable will be
placed in writable storage.
<A NAME="IDX575"></A>
<A NAME="IDX576"></A>
<A NAME="IDX577"></A>
<P>
Although the VMS linker does distinguish between upper and lower case
letters in global symbols, most VMS compilers convert all such symbols
into upper case and most run-time library routines also have upper case
names.  To be able to reliably call such routines, GNU CC (by means of
the assembler GAS) converts global symbols into upper case like other
VMS compilers.  However, since the usual practice in C is to distinguish
case, GNU CC (via GAS) tries to preserve usual C behavior by augmenting
each name that is not all lower case.  This means truncating the name
to at most 23 characters and then adding more characters at the end
which encode the case pattern of those 23.   Names which contain at
least one dollar sign are an exception; they are converted directly into
upper case without augmentation.
<P>
Name augmentation yields bad results for programs that use precompiled
libraries (such as Xlib) which were generated by another compiler.  You
can use the compiler option <SAMP>`/NOCASE_HACK'</SAMP> to inhibit augmentation;
it makes external C functions and variables case-independent as is usual
on VMS.  Alternatively, you could write all references to the functions
and variables in such libraries using lower case; this will work on VMS,
but is not portable to other systems.  The compiler option <SAMP>`/NAMES'</SAMP>
also provides control over global name handling.
<P>
Function and variable names are handled somewhat differently with GNU
C++.  The GNU C++ compiler performs <DFN>name mangling</DFN> on function
names, which means that it adds information to the function name to
describe the data types of the arguments that the function takes.  One
result of this is that the name of a function can become very long.
Since the VMS linker only recognizes the first 31 characters in a name,
special action is taken to ensure that each function and variable has a
unique name that can be represented in 31 characters.
<P>
If the name (plus a name augmentation, if required) is less than 32
characters in length, then no special action is performed.  If the name
is longer than 31 characters, the assembler (GAS) will generate a
hash string based upon the function name, truncate the function name to
23 characters, and append the hash string to the truncated name.  If the
<SAMP>`/VERBOSE'</SAMP> compiler option is used, the assembler will print both
the full and truncated names of each symbol that is truncated.
<P>
The <SAMP>`/NOCASE_HACK'</SAMP> compiler option should not be used when you are
compiling programs that use libg++.  libg++ has several instances of
objects (i.e.  <CODE>Filebuf</CODE> and <CODE>filebuf</CODE>) which become
indistinguishable in a case-insensitive environment.  This leads to
cases where you need to inhibit augmentation selectively (if you were
using libg++ and Xlib in the same program, for example).  There is no
special feature for doing this, but you can get the result by defining a
macro for each mixed case symbol for which you wish to inhibit
augmentation.  The macro should expand into the lower case equivalent of
itself.  For example:
<P>
<PRE>
#define StuDlyCapS studlycaps
</PRE>
<P>
These macro definitions can be placed in a header file to minimize the
number of changes to your source code.
<P>
Here is a list of all the passes of the compiler and their source files.
Also included is a description of where debugging dumps can be requested
with <SAMP>`-d'</SAMP> options.
<P>
<UL>
<LI>
Parsing.  This pass reads the entire text of a function definition,
constructing partial syntax trees.  This and RTL generation are no longer
truly separate passes (formerly they were), but it is easier to think
of them as separate.

The tree representation does not entirely follow C syntax, because it is
intended to support other languages as well.

Language-specific data type analysis is also done in this pass, and every
tree node that represents an expression has a data type attached.
Variables are represented as declaration nodes.

<A NAME="IDX579"></A>
<A NAME="IDX580"></A>
<A NAME="IDX578"></A>
Constant folding and some arithmetic simplifications are also done
during this pass.

The language-independent source files for parsing are <TT>`tree.c'</TT>,
<TT>`fold-const.c'</TT>, and <TT>`stor-layout.c'</TT>.
There are also header files <TT>`tree.h'</TT> and <TT>`tree.def'</TT>
which define the format of the tree representation.
The source files to parse C are 
<TT>`c-parse.in'</TT>, 
<TT>`c-decl.c'</TT>,
<TT>`c-typeck.c'</TT>, 
<TT>`c-aux-info.c'</TT>,
<TT>`c-convert.c'</TT>, 
and <TT>`c-lang.c'</TT>
along with header files 
<TT>`c-lex.h'</TT>, and
<TT>`c-tree.h'</TT>.

The source files for parsing C++ are <TT>`cp-parse.y'</TT>,
<TT>`cp-class.c'</TT>,<BR>
<TT>`cp-cvt.c'</TT>, <TT>`cp-decl.c'</TT>, <TT>`cp-decl2.c'</TT>,
<TT>`cp-dem.c'</TT>, <TT>`cp-except.c'</TT>,<BR>
<TT>`cp-expr.c'</TT>, <TT>`cp-init.c'</TT>, <TT>`cp-lex.c'</TT>,
<TT>`cp-method.c'</TT>, <TT>`cp-ptree.c'</TT>,<BR>
<TT>`cp-search.c'</TT>, <TT>`cp-tree.c'</TT>, <TT>`cp-type2.c'</TT>, and
<TT>`cp-typeck.c'</TT>, along with header files <TT>`cp-tree.def'</TT>,
<TT>`cp-tree.h'</TT>, and <TT>`cp-decl.h'</TT>.

The special source files for parsing Objective C are
<TT>`objc-parse.y'</TT>, <TT>`objc-actions.c'</TT>, <TT>`objc-tree.def'</TT>, and
<TT>`objc-actions.h'</TT>.  Certain C-specific files are used for this as
well.

The file <TT>`c-common.c'</TT> is also used for all of the above languages.

<A NAME="IDX581"></A>
<LI>
RTL generation.  This is the conversion of syntax tree into RTL code.
It is actually done statement-by-statement during parsing, but for
most purposes it can be thought of as a separate pass.

<A NAME="IDX582"></A>
This is where the bulk of target-parameter-dependent code is found,
since often it is necessary for strategies to apply only when certain
standard kinds of instructions are available.  The purpose of named
instruction patterns is to provide this information to the RTL
generation pass.

<A NAME="IDX583"></A>
Optimization is done in this pass for <CODE>if</CODE>-conditions that are
comparisons, boolean operations or conditional expressions.  Tail
recursion is detected at this time also.  Decisions are made about how
best to arrange loops and how to output <CODE>switch</CODE> statements.

The source files for RTL generation include 
<TT>`stmt.c'</TT>,
<TT>`calls.c'</TT>, 
<TT>`expr.c'</TT>, 
<TT>`explow.c'</TT>,
<TT>`expmed.c'</TT>, 
<TT>`function.c'</TT>, 
<TT>`optabs.c'</TT> 
and <TT>`emit-rtl.c'</TT>.  
Also, the file
<TT>`insn-emit.c'</TT>, generated from the machine description by the
program <CODE>genemit</CODE>, is used in this pass.  The header file
<TT>`expr.h'</TT> is used for communication within this pass.
<A NAME="IDX585"></A>
<A NAME="IDX584"></A>
The header files <TT>`insn-flags.h'</TT> and <TT>`insn-codes.h'</TT>,
generated from the machine description by the programs <CODE>genflags</CODE>
and <CODE>gencodes</CODE>, tell this pass which standard names are available
for use and which patterns correspond to them.
Aside from debugging information output, none of the following passes
refers to the tree structure representation of the function (only
part of which is saved).

<A NAME="IDX586"></A>
The decision of whether the function can and should be expanded inline
in its subsequent callers is made at the end of rtl generation.  The
function must meet certain criteria, currently related to the size of
the function and the types and number of parameters it has.  Note that
this function may contain loops, recursive calls to itself
(tail-recursive functions can be inlined!), gotos, in short, all
constructs supported by GNU CC.  The file <TT>`integrate.c'</TT> contains
the code to save a function's rtl for later inlining and to inline that
rtl when the function is called.  The header file <TT>`integrate.h'</TT>
is also used for this purpose.

The option <SAMP>`-dr'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.rtl'</SAMP> to
the input file name.

<A NAME="IDX588"></A>
<A NAME="IDX589"></A>
<A NAME="IDX587"></A>
<LI>
Jump optimization.  This pass simplifies jumps to the following
instruction, jumps across jumps, and jumps to jumps.  It deletes
unreferenced labels and unreachable code, except that unreachable code
that contains a loop is not recognized as unreachable in this pass.
(Such loops are deleted later in the basic block analysis.)  It also
converts some code originally written with jumps into sequences of
instructions that directly set values from the results of comparisons,
if the machine has such instructions.

Jump optimization is performed two or three times.  The first time is
immediately following RTL generation.  The second time is after CSE,
but only if CSE says repeated jump optimization is needed.  The
last time is right before the final pass.  That time, cross-jumping
and deletion of no-op move instructions are done together with the
optimizations described above.

The source file of this pass is <TT>`jump.c'</TT>.

The option <SAMP>`-dj'</SAMP> causes a debugging dump of the RTL code after
this pass is run for the first time.  This dump file's name is made by
appending <SAMP>`.jump'</SAMP> to the input file name.

<A NAME="IDX590"></A>
<LI>
Register scan.  This pass finds the first and last use of each
register, as a guide for common subexpression elimination.  Its source
is in <TT>`regclass.c'</TT>.

<A NAME="IDX591"></A>
<LI>
Jump threading.  This pass detects a condition jump that branches to an
identical or inverse test.  Such jumps can be <SAMP>`threaded'</SAMP> through
the second conditional test.  The source code for this pass is in
<TT>`jump.c'</TT>.  This optimization is only performed if
<SAMP>`-fthread-jumps'</SAMP> is enabled.

<A NAME="IDX593"></A>
<A NAME="IDX592"></A>
<LI>
Common subexpression elimination.  This pass also does constant
propagation.  Its source file is <TT>`cse.c'</TT>.  If constant
propagation causes conditional jumps to become unconditional or to
become no-ops, jump optimization is run again when CSE is finished.

The option <SAMP>`-ds'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.cse'</SAMP> to
the input file name.

<A NAME="IDX595"></A>
<A NAME="IDX596"></A>
<A NAME="IDX594"></A>
<LI>
Loop optimization.  This pass moves constant expressions out of loops,
and optionally does strength-reduction and loop unrolling as well.
Its source files are <TT>`loop.c'</TT> and <TT>`unroll.c'</TT>, plus the header
<TT>`loop.h'</TT> used for communication between them.  Loop unrolling uses
some functions in <TT>`integrate.c'</TT> and the header <TT>`integrate.h'</TT>.

The option <SAMP>`-dL'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.loop'</SAMP> to
the input file name.

<LI>
If <SAMP>`-frerun-cse-after-loop'</SAMP> was enabled, a second common
subexpression elimination pass is performed after the loop optimization
pass.  Jump threading is also done again at this time if it was specified.

The option <SAMP>`-dt'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.cse2'</SAMP> to
the input file name.

<A NAME="IDX598"></A>
<A NAME="IDX597"></A>
<LI>
Stupid register allocation is performed at this point in a
nonoptimizing compilation.  It does a little data flow analysis as
well.  When stupid register allocation is in use, the next pass
executed is the reloading pass; the others in between are skipped.
The source file is <TT>`stupid.c'</TT>.

<A NAME="IDX600"></A>
<A NAME="IDX601"></A>
<A NAME="IDX599"></A>
<LI>
Data flow analysis (<TT>`flow.c'</TT>).  This pass divides the program
into basic blocks (and in the process deletes unreachable loops); then
it computes which pseudo-registers are live at each point in the
program, and makes the first instruction that uses a value point at
the instruction that computed the value.

<A NAME="IDX602"></A>
This pass also deletes computations whose results are never used, and
combines memory references with add or subtract instructions to make
autoincrement or autodecrement addressing.

The option <SAMP>`-df'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.flow'</SAMP> to
the input file name.  If stupid register allocation is in use, this
dump file reflects the full results of such allocation.

<A NAME="IDX603"></A>
<LI>
Instruction combination (<TT>`combine.c'</TT>).  This pass attempts to
combine groups of two or three instructions that are related by data
flow into single instructions.  It combines the RTL expressions for
the instructions by substitution, simplifies the result using algebra,
and then attempts to match the result against the machine description.

The option <SAMP>`-dc'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.combine'</SAMP>
to the input file name.

<A NAME="IDX605"></A>
<A NAME="IDX604"></A>
<LI>
Instruction scheduling (<TT>`sched.c'</TT>).  This pass looks for
instructions whose output will not be available by the time that it is
used in subsequent instructions.  (Memory loads and floating point
instructions often have this behavior on RISC machines).  It re-orders
instructions within a basic block to try to separate the definition and
use of items that otherwise would cause pipeline stalls.

Instruction scheduling is performed twice.  The first time is immediately
after instruction combination and the second is immediately after reload.

The option <SAMP>`-dS'</SAMP> causes a debugging dump of the RTL code after this
pass is run for the first time.  The dump file's name is made by
appending <SAMP>`.sched'</SAMP> to the input file name.

<A NAME="IDX606"></A>
<LI>
Register class preferencing.  The RTL code is scanned to find out
which register class is best for each pseudo register.  The source
file is <TT>`regclass.c'</TT>.

<A NAME="IDX608"></A>
<A NAME="IDX607"></A>
<LI>
Local register allocation (<TT>`local-alloc.c'</TT>).  This pass allocates
hard registers to pseudo registers that are used only within one basic
block.  Because the basic block is linear, it can use fast and
powerful techniques to do a very good job.

The option <SAMP>`-dl'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.lreg'</SAMP> to
the input file name.

<A NAME="IDX609"></A>
<LI>
Global register allocation (<TT>`global.c'</TT>).  This pass
allocates hard registers for the remaining pseudo registers (those
whose life spans are not contained in one basic block).

<A NAME="IDX610"></A>
<LI>
Reloading.  This pass renumbers pseudo registers with the hardware
registers numbers they were allocated.  Pseudo registers that did not
get hard registers are replaced with stack slots.  Then it finds
instructions that are invalid because a value has failed to end up in
a register, or has ended up in a register of the wrong kind.  It fixes
up these instructions by reloading the problematical values
temporarily into registers.  Additional instructions are generated to
do the copying.

The reload pass also optionally eliminates the frame pointer and inserts
instructions to save and restore call-clobbered registers around calls.

Source files are <TT>`reload.c'</TT> and <TT>`reload1.c'</TT>, plus the header
<TT>`reload.h'</TT> used for communication between them.

The option <SAMP>`-dg'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.greg'</SAMP> to
the input file name.

<A NAME="IDX612"></A>
<A NAME="IDX611"></A>
<LI>
Instruction scheduling is repeated here to try to avoid pipeline stalls
due to memory loads generated for spilled pseudo registers.

The option <SAMP>`-dR'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.sched2'</SAMP>
to the input file name.

<A NAME="IDX614"></A>
<A NAME="IDX613"></A>
<LI>
Jump optimization is repeated, this time including cross-jumping
and deletion of no-op move instructions.

The option <SAMP>`-dJ'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.jump2'</SAMP>
to the input file name.

<A NAME="IDX616"></A>
<A NAME="IDX615"></A>
<LI>
Delayed branch scheduling.  This optional pass attempts to find
instructions that can go into the delay slots of other instructions,
usually jumps and calls.  The source file name is <TT>`reorg.c'</TT>.  

The option <SAMP>`-dd'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.dbr'</SAMP>
to the input file name.

<A NAME="IDX617"></A>
<LI>
Conversion from usage of some hard registers to usage of a register
stack may be done at this point.  Currently, this is supported only
for the floating-point registers of the Intel 80387 coprocessor.   The
source file name is <TT>`reg-stack.c'</TT>.

The options <SAMP>`-dk'</SAMP> causes a debugging dump of the RTL code after
this pass.  This dump file's name is made by appending <SAMP>`.stack'</SAMP>
to the input file name.

<A NAME="IDX619"></A>
<A NAME="IDX618"></A>
<LI>
Final.  This pass outputs the assembler code for the function.  It is
also responsible for identifying spurious test and compare
instructions.  Machine-specific peephole optimizations are performed
at the same time.  The function entry and exit sequences are generated
directly as assembler code in this pass; they never exist as RTL.

The source files are <TT>`final.c'</TT> plus <TT>`insn-output.c'</TT>; the
latter is generated automatically from the machine description by the
tool <TT>`genoutput'</TT>.  The header file <TT>`conditions.h'</TT> is used
for communication between these files.

<A NAME="IDX620"></A>
<LI>
Debugging information output.  This is run after final because it must
output the stack slot offsets for pseudo registers that did not get
hard registers.  Source files are <TT>`dbxout.c'</TT> for DBX symbol table
format, <TT>`sdbout.c'</TT> for SDB symbol table format, and
<TT>`dwarfout.c'</TT> for DWARF symbol table format.
</UL>
<P>
Some additional files are used by all or many passes:
<P>
<UL>
<LI>
Every pass uses <TT>`machmode.def'</TT> and <TT>`machmode.h'</TT> which define
the machine modes.

<LI>
Several passes use <TT>`real.h'</TT>, which defines the default
representation of floating point constants and how to operate on them.

<LI>
All the passes that work with RTL use the header files <TT>`rtl.h'</TT>
and <TT>`rtl.def'</TT>, and subroutines in file <TT>`rtl.c'</TT>.  The tools
<CODE>gen*</CODE> also use these files to read and work with the machine
description RTL.

<A NAME="IDX621"></A>
<LI>
Several passes refer to the header file <TT>`insn-config.h'</TT> which
contains a few parameters (C macro definitions) generated
automatically from the machine description RTL by the tool
<CODE>genconfig</CODE>.

<A NAME="IDX622"></A>
<LI>
Several passes use the instruction recognizer, which consists of
<TT>`recog.c'</TT> and <TT>`recog.h'</TT>, plus the files <TT>`insn-recog.c'</TT>
and <TT>`insn-extract.c'</TT> that are generated automatically from the
machine description by the tools <TT>`genrecog'</TT> and
<TT>`genextract'</TT>.
<LI>
Several passes use the header files <TT>`regs.h'</TT> which defines the
information recorded about pseudo register usage, and <TT>`basic-block.h'</TT>
which defines the information recorded about basic blocks.

<LI>
<TT>`hard-reg-set.h'</TT> defines the type <CODE>HARD_REG_SET</CODE>, a bit-vector
with a bit for each hard register, and some macros to manipulate it.
This type is just <CODE>int</CODE> if the machine has few enough hard registers;
otherwise it is an array of <CODE>int</CODE> and some of the macros expand
into loops.

<LI>
Several passes use instruction attributes.  A definition of the
attributes defined for a particular machine is in file
<TT>`insn-attr.h'</TT>, which is generated from the machine description by
the program <TT>`genattr'</TT>.  The file <TT>`insn-attrtab.c'</TT> contains
subroutines to obtain the attribute values for insns.  It is generated
from the machine description by the program <TT>`genattrtab'</TT>.</UL>
<P>
<HR>
Go to the <A HREF="usegcc_1.html">first</A>, <A HREF="usegcc_137.html">previous</A>, <A HREF="usegcc_139.html">next</A>, <A HREF="usegcc_139.html">last</A> section, <A HREF="usegcc_toc.html">table of contents</A>.
</BODY>
</HTML>
