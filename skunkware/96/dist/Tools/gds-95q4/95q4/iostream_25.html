<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from iostream.texi on 9 October 1995 -->

<TITLE>The GNU C++ Iostream Library - Strings</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="iostream_1.html">first</A>, <A HREF="iostream_24.html">previous</A>, <A HREF="iostream_26.html">next</A>, <A HREF="iostream_35.html">last</A> section, <A HREF="iostream_toc.html">table of contents</A>.
<HR>
<H2><A NAME="SEC25" HREF="iostream_toc.html#TOC25">Reading and writing in memory</A></H2>
<P>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>
<A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<P>
The classes <CODE>istrstream</CODE>, <CODE>ostrstream</CODE>, and <CODE>strstream</CODE>
provide some additional features for reading and writing strings in
memory--both static strings, and dynamically allocated strings.  The
underlying class <CODE>strstreambase</CODE> provides some features common to
all three; <CODE>strstreambuf</CODE> underlies that in turn.
<P>
<A NAME="IDX157"></A>
<U>Constructor:</U>  <B>istrstream::istrstream</B> <I>(const char* <VAR>str</VAR> [, int <VAR>size</VAR>])</I><P>
Associate the new input string class <CODE>istrstream</CODE> with an existing
static string starting at <VAR>str</VAR>, of size <VAR>size</VAR>.  If you do not
specify <VAR>size</VAR>, the string is treated as a <CODE>NUL</CODE> terminated string.
<P>
<A NAME="IDX158"></A>
<U>Constructor:</U>  <B>ostrstream::ostrstream</B> <I>()</I><P>
Create a new stream for output to a dynamically managed string, which
will grow as needed.
<P>
<A NAME="IDX159"></A>
<U>Constructor:</U>  <B>ostrstream::ostrstream</B> <I>(char* <VAR>str</VAR>, int <VAR>size</VAR> [,int <VAR>mode</VAR>])</I><P>
A new stream for output to a statically defined string of length
<VAR>size</VAR>, starting at <VAR>str</VAR>.  You may optionally specify one of
the modes described for <CODE>ifstream::ifstream</CODE>; if you do not specify
one, the new stream is simply open for output, with mode <CODE>ios::out</CODE>.
<P>
<A NAME="IDX160"></A>
<U>Method:</U> int <B>ostrstream::pcount</B> <I>()</I><P>
Report the current length of the string associated with this <CODE>ostrstream</CODE>.
<P>
<A NAME="IDX161"></A>
<U>Method:</U> char* <B>ostrstream::str</B> <I>()</I><P>
A pointer to the string managed by this <CODE>ostrstream</CODE>.  Implies
<SAMP>`ostrstream::freeze()'</SAMP>.
<P>
Note that if you want the string to be nul-terminated,
you must do that yourself (perhaps by writing ends to the stream).
<P>
<A NAME="IDX162"></A>
<U>Method:</U> void <B>ostrstream::freeze</B> <I>([int <VAR>n</VAR>])</I><P>
If <VAR>n</VAR> is nonzero (the default), declare that the string associated
with this <CODE>ostrstream</CODE> is not to change dynamically; while frozen,
it will not be reallocated if it needs more space, and it will not be
deallocated when the <CODE>ostrstream</CODE> is destroyed.  Use
<SAMP>`freeze(1)'</SAMP> if you refer to the string as a pointer after creating
it via <CODE>ostrstream</CODE> facilities.
<P>
<SAMP>`freeze(0)'</SAMP> cancels this declaration, allowing a dynamically
allocated string to be freed when its <CODE>ostrstream</CODE> is destroyed.
<P>
If this <CODE>ostrstream</CODE> is already static--that is, if it was created
to manage an existing statically allocated string---<CODE>freeze</CODE> is
unnecessary, and has no effect.
<P>
<A NAME="IDX163"></A>
<U>Method:</U> int <B>ostrstream::frozen</B> <I>()</I><P>
Test whether <CODE>freeze(1)</CODE> is in effect for this string.
<P>
<A NAME="IDX164"></A>
<U>Method:</U> strstreambuf* <B>strstreambase::rdbuf</B> <I>()</I><P>
A pointer to the underlying <CODE>strstreambuf</CODE>.
<P>
<HR>
Go to the <A HREF="iostream_1.html">first</A>, <A HREF="iostream_24.html">previous</A>, <A HREF="iostream_26.html">next</A>, <A HREF="iostream_35.html">last</A> section, <A HREF="iostream_toc.html">table of contents</A>.
</BODY>
</HTML>
