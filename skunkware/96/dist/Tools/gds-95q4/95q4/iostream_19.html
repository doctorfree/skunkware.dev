<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from iostream.texi on 9 October 1995 -->

<TITLE>The GNU C++ Iostream Library - String Input</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="iostream_1.html">first</A>, <A HREF="iostream_18.html">previous</A>, <A HREF="iostream_20.html">next</A>, <A HREF="iostream_35.html">last</A> section, <A HREF="iostream_toc.html">table of contents</A>.
<HR>
<H3><A NAME="SEC19" HREF="iostream_toc.html#TOC19">Reading strings</A></H3>
<P>
Use these methods to read strings (for example, a line at a time) from
the input stream:
<P>
<A NAME="IDX94"></A>
<U>Method:</U> istream&#38; <B>istream::get</B> <I>(char* <VAR>c</VAR>, int <VAR>len</VAR> [, char <VAR>delim</VAR>])</I><P>
Read a string from the input stream, into the array at <VAR>c</VAR>.
<P>
The remaining arguments limit how much to read: up to <SAMP>`len-1'</SAMP>
characters, or up to (but not including) the first occurrence in the
input of a particular delimiter character <VAR>delim</VAR>---newline
(<CODE>\n</CODE>) by default.  (Naturally, if the stream reaches end of file
first, that too will terminate reading.)
<P>
If <VAR>delim</VAR> was present in the input, it remains available as if
unread; to discard it instead, see <CODE>iostream::getline</CODE>.
<P>
<CODE>get</CODE> writes <SAMP>`\0'</SAMP> at the end of the string, regardless
of which condition terminates the read.
<P>
<A NAME="IDX95"></A>
<U>Method:</U> istream&#38; <B>istream::get</B> <I>(streambuf&#38; <VAR>sb</VAR> [, char <VAR>delim</VAR>])</I><P>
Read characters from the input stream and copy them on the
<CODE>streambuf</CODE> object <VAR>sb</VAR>.  Copying ends either just before the
next instance of the delimiter character <VAR>delim</VAR> (newline <CODE>\n</CODE>
by default), or when either stream ends.   If <VAR>delim</VAR> was present in
the input, it remains available as if unread.
<P>
<A NAME="IDX96"></A>
<U>Method:</U> istream&#38; <B>istream::getline</B> <I>(<VAR>charptr</VAR>, int <VAR>len</VAR> [, char <VAR>delim</VAR>])</I><P>
Read a line from the input stream, into the array at <VAR>charptr</VAR>.
<VAR>charptr</VAR> may be any of three kinds of pointer: <CODE>char*</CODE>,
<CODE>unsigned char*</CODE>, or <CODE>signed char*</CODE>.
<P>
The remaining arguments limit how much to read: up to (but not
including) the first occurrence in the input of a line delimiter
character <VAR>delim</VAR>---newline (<CODE>\n</CODE>) by default, or up to
<SAMP>`len-1'</SAMP> characters (or to end of file, if that happens sooner).
<P>
If <CODE>getline</CODE> succeeds in reading a "full line", it also discards
the trailing delimiter character from the input stream.  (To preserve it
as available input, see the similar form of <CODE>iostream::get</CODE>.)
<P>
If <VAR>delim</VAR> was <EM>not</EM> found before <VAR>len</VAR> characters or end
of file, <CODE>getline</CODE> sets the <CODE>ios::fail</CODE> flag, as well as the
<CODE>ios::eof</CODE> flag if appropriate.
<P>
<CODE>getline</CODE> writes a null character at the end of the string, regardless
of which condition terminates the read.
<P>
<A NAME="IDX97"></A>
<U>Method:</U> istream&#38; <B>istream::read</B> <I>(<VAR>pointer</VAR>, int <VAR>len</VAR>)</I><P>
Read <VAR>len</VAR> bytes into the location at <VAR>pointer</VAR>, unless the
input ends first.
<P>
<VAR>pointer</VAR> may be of type <CODE>char*</CODE>, <CODE>void*</CODE>, <CODE>unsigned
char*</CODE>, or <CODE>signed char*</CODE>.
<P>
If the <CODE>istream</CODE> ends before reading <VAR>len</VAR> bytes, <CODE>read</CODE>
sets the <CODE>ios::fail</CODE> flag.
<P>
<A NAME="IDX98"></A>
<U>Method:</U> istream&#38; <B>istream::gets</B> <I>(char **<VAR>s</VAR> [, char <VAR>delim</VAR>])</I><P>
A GNU extension, to read an arbitrarily long string
from the current input position to the next instance of the <VAR>delim</VAR>
character (newline <CODE>\n</CODE> by default).
<P>
To permit reading a string of arbitrary length, <CODE>gets</CODE> allocates
whatever memory is required.  Notice that the first argument <VAR>s</VAR> is
an address to record a character pointer, rather than the pointer
itself.
<P>
<A NAME="IDX99"></A>
<U>Method:</U> istream&#38; <B>istream::scan</B> <I>(const char *format ...)</I><P>
A GNU extension, similar to <CODE>fscanf(<VAR>file</VAR>,
<VAR>format</VAR>, ...)</CODE>.  The <VAR>format</VAR> is a <CODE>scanf</CODE>-style format
control string, which is used to read the variables in the remainder of
the argument list from the <CODE>istream</CODE>.
<P>
<A NAME="IDX100"></A>
<U>Method:</U> istream&#38; <B>istream::vscan</B> <I>(const char *format, va_list args)</I><P>
Like <CODE>istream::scan</CODE>, but takes a single <CODE>va_list</CODE> argument.
<P>
<HR>
Go to the <A HREF="iostream_1.html">first</A>, <A HREF="iostream_18.html">previous</A>, <A HREF="iostream_20.html">next</A>, <A HREF="iostream_35.html">last</A> section, <A HREF="iostream_toc.html">table of contents</A>.
</BODY>
</HTML>
