<HTML><HEAD><TITLE>XV: The Control Window</TITLE></HEAD>
<BODY><H1>The Control Window</H1>
<IMG SRC="fig-003.gif" WIDTH=454 HEIGHT=378><BR>
<P>The  <I>xv controls</I> window is the central point of control for the program, 
which just goes to show how
appropriately it was named.  It contains controls to resize the current 
image, flip and rotate it, load and
save different files, and bring up the other  <I>xv</I> windows.  It can be brought 
up by clicking the Right mouse
button in the image window, or by pressing the 
 <B>?</B>
 key inside any open  <I>xv</I> window.  Doing either of these
things while the  <I>xv controls</I> window is visible will hide it.</P>
<P>All of the following commands may be executed by either clicking the 
appropriate command button, or
typing the keyboard equivalent (where given) into any open  <I>xv</I> window.</P>
<A NAME="resizing-commands"><H2>  Resizing Commands</H2></A>
<P>The resizing commands have all been moved to the 
 <B>Image Size </B>
menu.  Note
that none of the 'resizing' commands modify the image in any way.  They only
affect how the image is displayed.  The image remains at its original size. 
 This
allows you to arbitrarily stretch and compact the image without compounding
error caused by earlier resizing.  In each case, the displayed image is
recomputed from the original internal image.</P>
<IMG SRC="fig-004.gif" WIDTH=117 HEIGHT=217><BR>
<P>Note:  The keyboard equivalents for each command are listed on the right 
side
of the menu.  These commands may be entered in the  <I>xv image </I>window, the  <I>xv
controls </I>window, the  <I>xv info</I> window, and the  <I>xv color editor</I> window.  They
may  <I>not </I> be entered in the  <I>xv visual schnauzer </I>windows, the  <I>xv load </I>window, 
or
the  <I>xv save </I> window.  The same goes for all other commands listed in the  <I>xv
controls</I> window.</P>
<DL>
<DT><IMG SRC="fig-005.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Attempts to return the image to its normal size, where one image pixel maps 
to
one screen pixel.  For example, if the image (or the current cropped 
portion of
the image) has a size of 320x200, this command will attempt to make the
image window 320 screen pixels wide by 200 screen pixels high.
<P>This command may fail in two cases.  If you're running a window manager
(such as  <I>mwm</I>) that enforces a minimum window size, and the 'normal' size is
too small, the image may get distorted.  See the note in "<A HREF="image-window.html#cropping">Cropping"</A>
 for more information.</P>
<P>Also, if the image is larger than the size of your screen, it will be shrunk
(preserving the aspect ratio) until it fits on the screen.  For example, if 
you try
to display a 1400x900 image on a 1280x1024 screen, the 
 <B>Normal</B>
 command
will display a 1280x823 image.  (1400/900  =  1280/823)</DD>
<DT><IMG SRC="fig-006.gif" WIDTH=113 HEIGHT=16></DT>
<DD>This command will make the displayed image the same size as the screen.  If
you are running a window manager that puts up a title bar, you'll find that 
the
title bar is now off the top of the screen.  To get the title bar back, simply shrink
the image to anything smaller than the size of the screen.  The window will 
be
moved so that the title bar is once again visible.</DD>
<DT><IMG SRC="fig-007.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Makes the image as large as possible, while preserving the aspect ratio.  
This
avoids the generally unwanted image distortion that 
 <B>Max Size</B>
 is capable of
generating.  For example, if you have a 320x200 image, and an 1280x1024
screen, doing the 
 <B>Maxpect</B>
 command will result in an image that is 1280x800.
 <B>Max Size</B>
, on the other hand, would've generated an image of size 1280x1024,
which would be appear 'stretched' vertically.</DD>
<DT><IMG SRC="fig-008.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Doubles the current size of the image, with the constraint that neither 
axis is
allowed to be larger than the screen.  For example, given a 320x200 image 
and
a 1280x1024 screen, the image can be doubled once (to 640x400), a second
time (to 1280x800), but a third time would make the image 1280x1024.  You'll
note that on the third time, the width didn't change at all, since it was 
already
at its maximum value.  Also note that the height wasn't allowed to double
(from 800 to 1600), but was truncated at its maximum value (1024).</DD>
<DT><IMG SRC="fig-009.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Halves the current size of the image, with the constraint that neither axis 
is
allowed to have a size less than 1 pixel.  Also, you may run into 'minimum
size' problems with your window manager.  See the note in "<A HREF="image-window.html#cropping">Cropping"</A>
 for more information.</P>
<P>Note that the window size is maintained as a pair of integers.  As a result 
you
may see some integer round-off problems.  For example, if you halve a 
265x185
image, you'll get a 132x92 image, which is just fine.  However, if you
 <B>Double Size</B>
 this image, you'll get a 264x184 image, not the 265x185 image
that you started with.</DD>
<DT><IMG SRC="fig-010.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Increases the current size of the image by 10%, subject to the constraint 
that the
image cannot be made larger than the screen size (in either axis).  For 
example,
issuing this command on a 320x200 image will result in a 352x220 image.
</DD>
<DT><IMG SRC="fig-011.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Decreases the current size of the image by 10%.  Neither axis of the image 
is
allowed to shrink below 1 pixel.  Also, you run the risk of running into
'minimum window size' problems with your window manager.</P>
<P>It should be noted that the 
 <B>10% Larger</B>
 and 
 <B>10% Smaller</B>
 commands have no
concept of an 'original size'.  They simply increase or decrease the current
image size by 10%.  As a result, they do not undo each other.  For example,
take a 320x200 image.  Do a 
 <B>10% Larger</B>
 and the image will be 352x220.  If
you issue the 
 <B>10% Smaller</B>
 command now, the image will be made (352 -
35.2)x(220 - 22), or 316x198.</DD>
<DT><IMG SRC="fig-012.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Lets you specify the exact size, or exact expansion, to display the image.  
Pops
open a dialog box where you can type a string of the form " <I>width </I>x  <I>height</I>",
" <I>expansion</I>%", or " <I>horiz-expansion</I>% <I> </I>x <I> vert-expansion</I>%".  The spaces between
numbers aren't necessary, but the 'x' and '%' characters are.
<IMG SRC="fig-013.gif" WIDTH=422 HEIGHT=209></DD>
<DT><IMG SRC="fig-014.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Applies the 'default aspect ratio' to the image.  This is done automatically
when the image is first loaded.  Normally, the default aspect ratio is 
'1:1', but
certain GIF files may have an aspect ratio encoded in them.  You can also 
set
the default aspect ratio via a command-line argument or an X resource.  See
"<A HREF="modifying-behavior.html#sizing-options">Image Sizing Options"</A>
 for more info.  The idea behind this
command is that you'd stretch the image manually (via your window manager)
to roughly the size you'd like, and then use the 
 <B>Aspect</B>
 command to fix up the
proportions.</P>
<P>Normally 
 <B>Aspect</B>
 expands one axis of the image to correct the aspect  ratio.  If
this would result in an image that is larger than the screen, the 
 <B>Aspect</B>
command will instead shrink one of the axes to correct the aspect ratio.</DD>
<DT><IMG SRC="fig-015.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Attempts to resize the image so that the ratio of width to height is equal 
to 4 to
3.  (e.g., 320x240, 400x300, etc.)  This is useful because many images were
meant to fill the screen on whatever system they were generated, and nearly 
all
video tubes have an aspect ratio of 4:3.  This command will stretch the 
image
so that things will probably look right on your X display (nearly all of 
which,
thankfully, have square pixels).  This command is particularly useful for
images which have really bizarre sizes (such as the 600x200 images
presumably meant for CGA, and the 640x350 16-color EGA images).
</DD>
<DT><IMG SRC="fig-016.gif" WIDTH=113 HEIGHT=16></DT>
<DD>Resizes the image to the nearest integral expansion or compression ratio.  
For
example, if an image is currently being displayed at "162.43% x 231%", the
 <B>IntExpnd</B>
 command will show the image at a "200% x 200%" expansion ratio.
Likewise, if an image is being shown at a "37% x 70%" expansion ratio,
 <B>IntExpnd</B>
 will resize it to "33% x 50%", the nearest integer compression ratios.</DD>
<DT><IMG SRC="fig-017.gif" WIDTH=36 HEIGHT=25></DT>
<DD>An alternate way of issuing the 
 <B>10% Larger</B>
 command.</DD>
<DT><IMG SRC="fig-018.gif" WIDTH=36 HEIGHT=25></DT>
<DD>An alternate way of issuing the 
 <B>10% Smaller</B>
 command.</DD>
</DL>
<A NAME="rotate-flip-commands"><H2>  Rotate/Flip Commands</H2></A>
<DL>
<DT><IMG SRC="fig-019.gif" WIDTH=36 HEIGHT=25></DT>
<DD>Rotates the  <I>entire</I> image (not the selection)  90
 clockwise.<BR>
Keyboard equivalent: 
 <B>t</B></P></DD>
<DT><IMG SRC="fig-020.gif" WIDTH=36 HEIGHT=25></DT>
<DD>
Rotates the <I> entire</I> image (not the selection)  90
 counter-clockwise.<BR>
Keyboard Equivalent: 
 <B>T</B></DD>
<DT><IMG SRC="fig-021.gif" WIDTH=36 HEIGHT=25></DT>
<DD>
Flips the image (or the selected area of the image) horizontally (around the
vertical center-line of the image).<BR>
Keyboard Equivalent: 
 <B>h</B></DD>
<DT><IMG SRC="fig-022.gif" WIDTH=36 HEIGHT=25></DT>
<DD>Flips the image (or the selected area of the image) vertically (around the
horizontal center-line of the image).<BR>
Keyboard Equivalent: 
 <B>v</B></DD>
</DL>

<A NAME="display-menu"><H2>  The Display Menu</H2></A>
<TABLE>
<TR>
<TD><IMG SRC="fig-023.gif" WIDTH=138 HEIGHT=185></TD>
<TD>
<P>This menu controls how the image is displayed on your screen.  None of these
commands  <I>actually</I> modifies the image itself, only how it is presented.
</P>
</TD>
</TR>
</TABLE>

<A NAME="dithering-commands"><H3>  Dithering Commands</H3></A>
<DL>
<DT><IMG SRC="fig-024.gif" WIDTH=134 HEIGHT=15></DT>
<DD>
<P>Returns the displayed image to its 'raw' state (where each pixel in the displayed
image is as close as possible to the corresponding pixel in the internal 
image).
In short, it turns off any dithering or smoothing.  This command is normally
disabled, and is only enabled  <I>after</I> you have issued a 
 <B>Dithered</B>
 or 
 <B>Smooth</B>
command..</DD>
<DT><IMG SRC="fig-025.gif" WIDTH=134 HEIGHT=16></DT>
<DD>Regenerates the displayed image by dithering with the available colors in an
attempt to approximate the original image.  This has a useful effect
 <I>only</I> if the
color allocation code failed to get all the colors it wanted.  If it  <I>did</I> 
get all the
desired colors, the 
 <B>Dither</B>
 command will just generate the same display image
as the 
 <B>Raw</B>
 command.  On the other hand, if you didn't get all the desired
colors, the 
 <B>Dither</B>
 command will try to approximate the missing colors by
dithering with the colors that  <I>were</I> obtained, which can help eliminate 
visible
banding, and such.  Note:  If you are running  <I>xv</I> on a 1-bit display the 
 <B>Dither</B>
command will be disabled, as the image will always be dithered for display.</DD>
<DT><IMG SRC="fig-026.gif" WIDTH=134 HEIGHT=16></DT>
<DD>
Smoothes out distortion caused by integer round-off when an image is
expanded or shrunk.  This is generally a desirable effect, however it can be
fairly time-consuming on large images, so by default it is not done
automatically.  See "<A HREF="modifying-behavior.html">Modifying  <I>xv</I> Behavior"</A>
 for more details.
Note that 
 <B>Smooth</B>
  <I>only</I> has a useful effect if the image has been resized.  If the
image is being displayed at its normal 1:1 expansion ratio, then the 
 <B>Smooth</B>
command will not have a useful effect.
<P>Note: if you are currently in '24-bit mode' (see "<A HREF="control-window.html#bit-menu">The 24/8 
Bit Menu"</A>
 for more info), the
 <B>Dithered</B>
 command is disabled, 
 <B>Raw</B>
 displays the image (dithered on an 8-bit display), and 
 <B>Smooth</B>
displays a smoothed version of the image (dithered on an 8-bit display).</P>
</DD>
</DL>

<A NAME="color-allocation-commands"><H3>Color Allocation Commands</H3></A>
<DL>
<DT><IMG SRC="fig-027.gif" WIDTH=134 HEIGHT=16></DT>
<DD>When turned on, forces  <I>xv</I> to use read/write color cells (ignored and 
disabled in
 <B>Use Std. Colormap</B>
 mode, below)..  Normally,  <I>xv</I> allocates read-only color
cells, which allows it to share colors with other programs.  If you use 
read/write
color cells, no other program can use the colormap entries that  <I>xv</I> is 
using, and
vice-versa.  The major advantage is that using read/write color cells 
allows the
 <B>Apply</B>
 function in the  <I>xv color editor</I> window to operate much faster, and
allows the 
 <B>Auto-Apply while dragging</B>
 feature to be used at all.  Also note that
this command is only enabled if you are running  <I>xv</I> on a  <I>PseudoColor</I> display.
See "<A HREF="color-allocation.html">Color Allocation in  <I>xv</I>"</A>
 for more information on display
modes.
</DD>
<DT><IMG SRC="fig-028.gif" WIDTH=134 HEIGHT=16></DT>
<DD><I>xv</I>'s normal color allocation mode.  For any given picture,  <I>xv</I> figures out 
what
colors should be allocated, and tries to allocate them (read-only, or 
read/write,
as determined by the 
 <B>Read/Write Colors</B>
 setting).  If any color allocation fails,
 <I>xv</I> will try a few other tricks, and generally just map the remaining colors 
(the
ones it didn't get) into the  <I>closest</I> colors that it  <I>did</I> get.
</DD>
<DT><IMG SRC="fig-029.gif" WIDTH=134 HEIGHT=16></DT>
<DD>When 
 <B>Perfect Colors</B>
 is turned on,  <I>xv</I> proceeds as in the 
 <B>Normal Colors</B>
 case.
If any color allocation request fails, all colors are freed, and  <I>xv</I>
 creates itself a private colormap, and tries all over again.  It is assumed
 that having a private colormap will provide more colors than allocating out
of the already partially-used system default colormap.
</DD>
<DT><IMG SRC="fig-030.gif" WIDTH=134 HEIGHT=16></DT>
<DD>Like 
 <B>Perfect Colors</B>
, but it doesn't even  <I>try</I> to allocate out of the system
colormap.  Instead, it starts off by creating its own colormap, and 
allocating
from there.  Slightly faster than 
 <B>Perfect Colors</B>
 mode.  Also useful, as certain
X servers (AIX 3.1 running on an RS6000, for instance)  <I>never</I> report an
allocation error for read-only color cells.  They just return the closest 
color
found in the system colormap.  Generally nice behavior, but it prevents 
 <B>Perfect
Colors</B>
 mode from ever allocating a colormap...
</DD>
<DT><IMG SRC="fig-031.gif" WIDTH=134 HEIGHT=16></DT>
<DD>
An entirely different color allocation mode.  Instead of picking the 
(generally
unique) colors that each image requires, this mode forces all images to be
displayed (dithered) using the same set of (standard) colors.  The downside 
is
that the images don't look as nice as they do in the other modes.  The 
upside is
that you can display many images simultaneously (by running more than one
copy of  <I>xv</I>) without instantly running out of colors.  The setting of 
 <B>Read/Write
Colors</B>
 <STRONG> </STRONG>is ignored while in this mode.  Also, this mode is the only one available
when you are displaying images in 24-bit mode.
</DD>
</DL>

<A NAME="root-display-modes"><H2>  Root Display Modes</H2></A>
<P>While  <I>xv</I> normally displays an image in its own window, it is also
possible for it to display images on the  <I>root window</I> (a.k.a. 'the
desktop').  You would normally use this feature from the command-
line, as part of some sort of X startup script, to put up a background
pattern or image of your choice.  See "<A HREF="modifying-behavior.html#root-window-options">Root Window
Options"</A>
 for further information on the relevant command-line
options.</P>
<P>You can also specify root display options interactively, while the
program is running, by using the 
 <B>Root</B>
 menu, as shown.</P>
<IMG SRC="fig-032.gif" WIDTH=186 HEIGHT=201>
<P>One note regarding root display:  it is not possible for  <I>xv</I> to receive
button presses or keyboard presses in the root window.  As such, there
are several functions that cannot be used while in a 'root' mode, such
as pixel tracking, image editing, pan and zoom operations, etc.  If you
want to do such things, you'll have to temporarily return to 'window' mode, 
and return to 'root' mode when
you're finished.  Also, when you are in a 'root' mode, you will not be able to get rid of the 
 <I>xv</I>  <I>controls</I> window.
At best you can iconify it (using your window manager).  There's a good 
reason for this.  If you  <I>could</I> get rid
of the window, there would be no way to ever get it back (since it won't 
see keypresses or mouse clicks in the
root window).</P>
<P>One other note:  If you are running  <I>xv</I> on certain 24-bit displays, where 
the 'default' visual type is an 8-bit
PseudoColor, but  <I>xv</I> in its cleverness has decided to use a 24-bit TrueColor 
mode, you will  <I>not</I> be able to
switch the display to a root mode.  This is because  <I>xv</I> requires the visual 
used in the 'window' mode to be the
same as the visual used for the 'root' modes.  In the case of these types 
of displays, it is not possible to put a
24-bit TrueColor image on the root window.  You can get this to work by 
using the '
 <TT>-visual default</TT>
'
command-line option, which will force  <I>xv</I>
 to use the 'default' visual for both the 'window' and 'root' modes.</P>
<P>Also note:  This is only necessary to get this menu to work on such 
displays.  If you use the '
 <TT>-root</TT>
' or
'
 <TT>-rmode</TT>
' command-line options,  <I>xv</I>
 will automatically use patented "DoTheRightThing" technology...</P>
<DL>
<DT><IMG SRC="fig-033.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Displays the image in a window.  If you were previously in a 'root' mode, 
the root window
will also be cleared.</DD>
<DT><IMG SRC="fig-034.gif" WIDTH=172 HEIGHT=18></DT>
<DD>The image is displayed in the root window.  One image is displayed aligned 
with the top-left
corner of the screen.  The image is then duplicated towards the bottom and 
right edges of the
screen, as many times as necessary to fill the screen.
</DD>
<DT><IMG SRC="fig-035.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Similar to 
 <B>Root: Tiled</B>
, except that the image is first shrunk so that its width and height are
integer divisors of the screen's width and height.  This keeps the images 
along the bottom and
right edges of the screen from being 'chopped-off'.</P>
<P>Note:  using any of the 'resizing' commands (such as 
 <B>Normal</B>
, 
 <B>Double Size</B>
, etc.) will lose the 'integer'-
ness of the image, and you'll have to re-select this mode to 'integer-ify' the image again.
</DD>
<DT><IMG SRC="fig-036.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Tiles the original image with versions that have been horizontally flipped, 
vertically flipped,
and both horizontally and vertically flipped.  This gets rid of the sharp 
dividing lines where
tiled images meet.  The effect is quite interesting.
</DD>
<DT><IMG SRC="fig-037.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Like 
 <B>Root: Mirrored</B>
, but also does the integer-ization described under the 
 <B>Root: Integer
Tiled</B>
 entry.
</DD>
<DT><IMG SRC="fig-038.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Like 
 <B>Root: Tiled</B>
, but it positions the images so that one of them is centered on the screen,
and the rest are tiled off in all directions.  Visually pleasing without 
the image size distortion
associated with 
 <B>Root: Integer Tiled</B>
.
</DD>
<DT><IMG SRC="fig-039.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Displays a single image centered in the root window, surrounded by black, 
or your choice of
any other solid color.  (See "<A HREF="modifying-behavior.html">Modifying  <I>xv</I> Behavior
"</A>
 for more information.)
</DD>
<DT><IMG SRC="fig-040.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Displays a single image centered in the root window, surrounded by a black 
and white 'warp'
pattern, which produces some mildly visually pleasing Moir effects.  The 
colors can also be
chosen by the user.  (See "<A HREF="modifying-behavior.html">Modifying  <I>xv</I> Behavior"</A>
 for details.)
</DD>
<DT><IMG SRC="fig-041.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Displays a single image centered in the root window, surrounded by a black 
and white 'brick'
pattern.  Again, the colors can be set by the user.

</DD>
<DT><IMG SRC="fig-042.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Tiles images on the root window such that the images are symmetric around 
the horizontal
and vertical center lines of the screen.
</DD>
<DT><IMG SRC="fig-043.gif" WIDTH=172 HEIGHT=18></DT>
<DD>Like the 
 <B>Root: symmetrical tiled</B>
 mode, but the images are also mirrored.
</DD>
</DL>
<P>Note:  The three 'centered' modes (
 <B>Root: Centered</B>
, 
 <B>Root: Centered, Warp</B>
, and 
 <B>Root: Centered,
Brick</B>
, but not 
 <B>Root: Center Tiled</B>
) require the creation of a Pixmap the size of the screen.  This can be a
fairly large request for resources, and will fail on a color X terminal 
with insufficient memory.  They can
also require the transmission of considerably more data than the other 
'root' modes.  If you're on a brain-
damaged X terminal hanging off a slow network, you should probably go 
somewhere else.  Barring that,
you should certainly avoid the 'centered' modes.</P>
<P>Also note:  If you quit  <I>xv</I> while displaying an image on the root window, 
the image will remain in the root
window, and the colors used by the image will remain allocated.  This is 
generally regarded as correct
behavior.  If you decide you want to get rid of the root image to free up 
resources, or simply because
you're sick of seeing it, the quickest route is to run '
 <TT>xv -clear</TT>
', which will clear the root window,
release any allocated colors, and exit.  Alternately,  <I>xsetroot</I> or any other 
X program that puts things in the
root window should be able to do the trick as well.</P>
<A NAME="bit-menu"><H2>  The 24/8 Bit Menu</H2></A>
<P> <I>xv </I>has a whopping grand total of  <I>two</I> internal image formats: 8-bit
colormapped, and 24-bit RGB.  Every image you load is converted to one
of these two formats, as part of the image loading procedure, before you
ever get to see the image.</P>
<P>There are a few crucial differences between these two modes.  In 8-bit 
mode, you have a colormap, and
thus color-editing changes (see "<A HREF="color-editor.html">The Color Editor"</A>
) can happen 
much more quickly.  On the
downside, most of the image editing functions only actually operate on 
24-bit images.  (Such as the
 <B>Algorithms</B>
 menu, described later in this section.)  If you use these functions,  <I>xv</I> 
will convert the 8-bit
image into a 24-bit image, operate on the 24-bit data, and convert the 
result back to an 8-bit image.  As a
result, artifacts can be introduced from the image conversions.  As such, 
if you're going to be doing a lot
of this sort of thing, switch to 24-bit mode first.</P>
<P>But I digress...</P>
<IMG SRC="fig-044.gif" WIDTH=132 HEIGHT=153>
<P>This menu lets you see which mode  <I>xv</I>
 is currently operating in, and lets you change modes.  You can also
force  <I>xv</I> to remain in the current mode, and select how the program will 
convert 24-bit images into 8-bit images.
</P>
<DL>
<DT><IMG SRC="fig-045.gif" WIDTH=128 HEIGHT=16></DT>
<DD>Forces the program into 
 <B>8-bit mode</B>
 when selected.  If you are currently
working on a 24-bit image, it will be converted into an 8-bit image using 
the
selected conversion algorithm (see below), and the 24-bit data will be 
thrown
away.
</DD>
<DT><IMG SRC="fig-046.gif" WIDTH=128 HEIGHT=16></DT>
<DD>Forces the program into 
 <B>24-bit mode</B>
 when selected.  If you currently working
on an 8-bit image, it will be converted into a 24-bit image and the 8-bit 
image
will be thrown away.  Note that if you are working on a 24-bit image, 
switch to
 <B>8-bit mode</B>
, and switch back to 
 <B>24-bit mode</B>
, your 24-bit data will have been
lost in the conversions.  A dialog box will pop up to alert you of this 
potential
problem.
</DD>
<DT><IMG SRC="fig-047.gif" WIDTH=128 HEIGHT=16></DT>
<DD>Normally,  <I>xv</I> will switch between 8 and 24-bit modes based on the image type
(if you load a 24-bit image, it'll switch to 
 <B>24-bit mode</B>
, otherwise it will use 
 <B>8-
bit mode</B>
).  Turning this option on will force  <I>xv</I> to remain in the current mode.
One reason that you might wish to this would be to lock  <I>xv</I> into 
 <B>8-bit mode</B>
 so
that 24-bit images are shown dithered with the 'Slow' algorithm (see below),
which produces better looking images on 8-bit displays.  (Just don't try to 
save
the image afterwards!)
</DD>
<DT><IMG SRC="fig-048.gif" WIDTH=128 HEIGHT=16></DT>
<DD>Converts 24-bit images to 8-bit images by dithering with a fixed 6x6x6 RGB
colormap.  It is the quickest of the three algorithms, but also generally 
produces
the worst images.  It can also be selected via the '-quick24' command-line
option or X resource.
</DD>
<DT><IMG SRC="fig-049.gif" WIDTH=128 HEIGHT=16></DT>
<DD>The default algorithm.  Takes about twice as long as the Fast algorithm.  
Uses
the median-cut algorithm to pick a set of 256 colors, and then dithers with
these colors.  It can be selected via the '-slow24' command-line option or X
resource.
</DD>
<DT><IMG SRC="fig-050.gif" WIDTH=128 HEIGHT=15></DT>
<DD>By far and away the slowest of the algorithms.  Can take up to ten times as 
long
as the Slow algorithm.  Uses a cleverer version of the median-cut algorithm 
to
pick a better set of 256 colors than the slow algorithm.  Does not dither.  
This
might look best if you're going to be expanding the image by very much, as 
the
dithering in the other two algorithms becomes very noticeable.  You can also
select this option via the '-best24' command-line option or X resource.
</DD>
</DL>
<P>Note that none of the three 24->8 algorithm choices immediately  <I>does</I>
anything.  They merely select which algorithm will be used the next time  <I>xv</I>
feels a need to convert a 24-bit image into an 8-bit image.
</P>
<A NAME="algorithms"><H2>  Image Algorithms</H2></A>
<P> <I>xv</I> now has the ability to run a number of standard image-processing
algorithms on the current image, or any rectangular portion of the current
image.  If there is a current selection rectangle (See "<A HREF="image-window.html#selection-rectangle">Selection
Rectangle"</A>
), the algorithm will only affect the selected area.  Otherwise, 
the
algorithms operate on the entire image.</P>
<IMG SRC="fig-054.gif" WIDTH=120 HEIGHT=233>
<P>Algorithms are chosen via the 
 <B>Algorithms</B>
 menu, and are executed
immediately.  Algorithms are cumulative, in that if you run an algorithm on
an image, and then run a second algorithm, the second algorithm operates on
the modified image produced by the first algorithm.  And so on.</P>
<P>See "<A HREF="adding-algorithms.html">Adding Algorithms to  <I>xv</I>"</A>
 for information on how you
can add additional algorithms to this menu.</P>
<P>Also, it should be noted that the algorithms operate on 24-bit images.  If 
you
are currently operating on an 8-bit image, and you run an algorithm, the
image will be converted up to 24-bits, the algorithm will be run, and the
result will be converted back to 8-bits using the currently selected 24->8 
algorithm.  As such, if you're
going to be doing a lot of algorithm-ing, you may find it faster to 
temporarily switch to 
 <B>24-bit mode</B>
.
Likewise, if you intend to run multiple algorithms on the same image (say, 
a 
 <B>Blur</B>
 followed by an
 <B>Emboss</B>
), you should  <I>definitely</I> switch to 
 <B>24-bit mode</B>
, to maintain full 24-bit precision on the
intermediate images (i.e., to prevent noise from being added to the image 
by any intermediate 24->8
conversions).
</P>
<DL>
<DT><IMG SRC="fig-051.gif" WIDTH=116 HEIGHT=16></DT>
<DD>The (normally dimmed-out) 
 <B>Undo All</B>
 selection undoes any and all algorithms
that have been run on the current image.  It restores the image to the 
state it
was in when the first algorithm was executed, and it also puts  <I>xv</I> back into 
the
8/24-bit mode it  <I>was</I> in.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> u</B>
</DD>
<DT><IMG SRC="fig-052.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs a convolution over each plane (red, green, blue) of the image, using a 
 <I>n*n</I>
convolution mask consisting of all 1's.  It has the effect of, for each 
pixel in the
image, replacing it with the average value of all the pixels in the  <I>n*n</I> 
rectangle
centered around the pixel in question.  When you select this command, a 
dialog
box is opened up to request the value for ' <I>n</I>'.  Values must be
greater than or equal to '3', and they must also be odd (e.g. 3,7,5,9,11).
Larger values blur the image to a greater extent.</P>
<P> <B>Warning!</B>
  This algorithm, due to its  <I>n</I>^2
 nature, can get very slow as  <I>n</I> is
increased.  Values above '15' aren't particularly recommended.</P>
<P>Note:  This command is a reasonable way to turn dithered black-and-white
images back into some semblance of the greyscale that they probably 
originally
started as.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> b</B>
</P>
</DD>
<DT><IMG SRC="fig-053.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs an edge-sharpening algorithm on the image, which attempts to maximize
contrast between adjacent pixels.  Prompts for a 'strength' value of 0% 
through 99%.<BR>Keyboard Equivalent:  
 <B>&lt;Meta> s</B>
</DD>
<DT><IMG SRC="fig-055.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs a convolution using a pair of convolutions, one which detects 
horizontal
edges, and one which detects vertical edges.  The convolution is done
separately for each plane (red, green, blue) of the image.  It is only done 
for
pixels that have the 3x3 mask fully contained within the image, to avoid 
pesky
edge conditions.  One note:  since it runs an edge detection separately for 
each
plane of the image, the results are colorful.  You'll get red edges when 
there are
edges in the red plane, yellow edges when there are edges in the red and 
green
planes, and so on.  If you'd like a traditional grey edge detection (based 
on the
overall intensity of each pixel), you should use the 
 <B>Saturation</B>
 dial in the  <I>xv
color editor</I> (See "<A HREF="color-editor.html#saturation-control">The Saturation Control"</A>
) to completely
desaturate all the colors in the image (turning it grey) first.  Then, the 
results
will also be grey.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> e</B>
</DD>
<DT><IMG SRC="fig-056.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs an algorithm that produces nifty 'embossed' images by using a variation
of the edge detection algorithm.  It produces greyscale (8-bit) images where
most of the image is shown as a medium gray.  'Leading' edges (edges found
on the top and left sides) are shown as a lighter gray, and 'trailing' edges
(bottom and right edges) are shown as a darker gray.  The image wind up
looking like pseudo-3-d, sort of like the Motif toolkit.  You can then use 
the
 <B>White</B>
 dial in the  <I>xv color editor</I> (See "<A HREF="color-editor.html#white-remapping-control">The White Remapping
Control"</A>
) to colorize the image as you see fit<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> m</B>
</DD>
<DT><IMG SRC="fig-057.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Does an 'oil transfer', as described in the book "Beyond Photography", by
Holzman.  It is a sort of localized smearing.  The basic algorithm is to 
take a
rectangle (7x7 in this case) centered around the current pixel, compute a
histogram of these (49) pixels, and replace the current pixel with the 'most
popular' pixel as determined by the histogram.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> o</B>
</DD>
<DT><IMG SRC="fig-058.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Blends a rectangular selection out of existence by replacing the selected 
area
with a radial gradient fill.  Each pixel on the edge of the selection 
retains its
original color, the pixel in the center is replaced by the average of all 
the edge
pixels, and all remaining pixels are replaced by the weighted average of the
center pixel and the edge pixel (along the line that runs through the center
pixel and the pixel being computed).</P>
<P>This is much easier to see than it is to explain.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> B</B>

</DD>
<DT><IMG SRC="fig-059.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Does arbitrary (smooth) rotation of the entire image (or the selected 
region).
You will be prompted to enter a rotation amount, in degrees.  Positive 
values
rotate the image counter-clockwise, negative values rotate the image 
clockwise.
The 
 <B>Copy Rotate</B>
 function makes a copy of the selection, rotates it, and pastes
it back on top of the original.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> t</B>
</DD>
<DT><IMG SRC="fig-060.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Also does arbitrary smooth rotation, as with the 
 <B>Copy Rotate </B>
command, but
this version clears the original image (using the 'current color', see
"<A HREF="image-window.html#displaying-pixel-values">Displaying Pixel Values"</A>
) before pasting the rotated version.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> T</B>
</DD>
<DT><IMG SRC="fig-061.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs a 'pixelization' algorithm, suitable for obscuring sensitive and/or 
naughty
parts of an image.  Pops open a dialog box which prompts for either a single
value ' <I>m</I>', or a pair of values ' <I>m</I>x <I>n</I>'.  Divides the image (or the selected 
region)
up into  <I>m</I>-by- <I>m</I> squares (if a single value was entered) or  <I>m</I>-by- <I>n</I> rectangles 
(if a
pair of values were entered).  Each area is filled with the average color 
of all
pixels contained within the area.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> p</B>
</DD>
<DT><IMG SRC="fig-062.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs a 'random spread' algorithm on the selected area of the image (or the
entire image).  Pops up a dialog box which prompts for either a single value
' <I>m</I>', or a pair of values ' <I>m</I>x <I>n</I>'.  In the case of the single value, each 
pixel in the
image is swapped with some other random pixel located within a distance of  <I>m</I>
pixels from the first pixel.  If two values are entered, each pixel is 
swapped
with another pixel located within 
 <I>m</I>, 
 <I>n</I> of the original pixel.  This can
produce an interesting 'de-rez' effect.  Whether it's useful or not is for 
you to
decide.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> S</B>

</DD>
<DT><IMG SRC="fig-063.gif" WIDTH=116 HEIGHT=16></DT>
<DD>Runs a despeckling algorithm, also known as a  <I>median filter</I> among
image-processing circles.  This algorithm is good at removing minor noise from an
image, such as you'll normally find on scanned-in faxes and the like.  It 
may
also prove useful for de-dithering images, turning black-and-white dithered
images into greyscale images, and dithered color images into undithered 
color
images.  Note that the 
 <B>Blur</B>
 algorithm can also be used in the same way, and
may do a better job of un-dithering.  However, the 
 <B>DeSpeckle</B>
 algorithm
generally leaves edges alone, unlike the 
 <B>Blur</B>
 algorithm, which blurs everything
uniformly.
<P>This algorithm runs through the selected area of the image, and for each 
pixel
in the image, looks at the  <I>m</I>-by- <I>m</I> square centered around the pixel.  It 
replaces
the pixel with the median value of the pixels found in the square.  As with 
the
 <B>Blur</B>
 algorithm, you will be prompted for a value of ' <I>m</I>'.  The value must not be
less than '3', and it must be odd.  Larger values have a greater effect, 
though
'3' should be sufficient for most purposes.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> k</B></DD>

<A NAME="cropping-commands"><H2>Cropping Commands</H2></A>
<DL>
<DT><IMG SRC="fig-064.gif" WIDTH=72 HEIGHT=25></DT>
</B>
<DD>Crops the image to the current selection rectangle.  This command is only
available when a cropping rectangle has been drawn on the image.  See
"<A HREF="image-window.html#cropping">Cropping"</A>
 for further information.<BR>
Keyboard Equivalent: 
 <B>c</B>
<DT><IMG SRC="fig-065.gif" WIDTH=72 HEIGHT=25></DT>
<DD>Returns the image to its normal, uncropped state.  This command is only
available after the image has been cropped.  See "<A HREF="image-window.html#cropping">Cropping"</A>
 
for
further information.<BR>
Keyboard Equivalent: 
 <B>u</B>
</DD>
<DT><IMG SRC="fig-066.gif" WIDTH=72 HEIGHT=25></DT>
<DD>Crops off any constant-color borders that exist in the image.  It will crop 
to the
smallest rectangle that encloses the 'interesting' section of the image.  
It may
not always appear to work because of minor invisible color changes in the
image.  As such, it works best on computer-generated images, and not as well
on scanned images.   In an attempt to get around this problem, if you
 <B>AutoCrop</B>
 while in 
 <B>24-bit Mode</B>
, it will crop off portions that change by a little
bit, not just portions that are exactly the same.  Not that it works all that well.<BR>
Keyboard Equivalent: 
 <B>C</B>
</DD>
</DL>
<P>Also, you can 'fine-crop' an image, by holding the 
 <B>&lt;Ctrl></B>
 key and pressing the arrow keys on your
keyboard.  Each press of the keys will remove one row (or column) of pixels 
from the appropriate edge.
For example, pressing 
 <B>&lt;Ctrl>&lt;Up></B>
 will crop off the bottom row of the image.  Likewise, 
 <B>&lt;Ctrl>&lt;Down></B>
will crop off the top row, 
 <B>&lt;Ctrl>&lt;Left> </B>
 will crop off the right edge, and 
 <B>&lt;Ctrl>&lt;Right></B>
 will crop off the
left edge.  It may sound backwards, but it does the Right Thing.
</P>
<P>This 'fine-cropping' will work regardless of whether or not there is a 
selection rectangle currently drawn.
If you accidentally crop too much off the image, you can use the 
 <B>UnCrop</B>
 command described above to get
the original image back.</P>
<P>Note that cropping never actually changes the image, only what portions are 
displayed.  The original
image can always be restored using the 
 <B>UnCrop</B>
 command.  Also, note that the 'cropping' commands and
the 'zoom' commands (See "<A HREF="image-window.html#zooming">Zooming
"</A>
) are related, in that both affect the 'visible portion' of
the image.  The cropping commands maintain the same expansion factors by making the window larger or
smaller, while the zooming commands maintain the same window size, and 
stretch the relevant portion of
the image to fit.  As such, the 
 <B>UnCrop</B>
 command will also undo an zooming that you may have done.</P>

<A NAME="cut-paste-commands"><H2>  Image Cut and Paste Commands</H2></A>
<P>A new feature added to Version 3.10 is the ability to cut and paste 
arbitrary rectangular portions of
images.  You can cut (and copy) and paste within a single image, between 
two different images, or even
between two running copies of  <I>xv.</I>  You can even cut or copy a portion of an 
image, exit  <I>xv</I>, go out for
dinner, come back, restart  <I>xv</I>
, and paste the previously-copied portion into the current image.</P>
<P>Copied image data is normally stored within the X Server's memory (in the '
 <TT>XV_CLIPBOARD</TT>
' property),
and remains there until some other data is copied, or until the X Server is 
reset (i.e., when you log off).
This allows you to transfer image data between different copies of  <I>xv</I>, and 
the  <I>xv</I>'s can even be running on
different machines.</P>
<P>If there is not enough server memory available to hold the copied image 
data (this can happen if you copy
a large amount of data, and you're using an X Terminal, as opposed to a 
workstation),  <I>xv</I> will detect this,
and fall back to using a file ('
 <TT>.xvclip</TT>
') in your home directory.  Needless to say, this precludes
transferring data between  <I>xv</I>
's running on different machines, but it's better than nothing.
<DL>
<DT><IMG SRC="fig-067.gif" WIDTH=36 HEIGHT=25></DT>
<DD> <B>Copy</B>
.  First, you must select a region to copy, via the selection rectangle
mechanism (See "<A HREF="image-window.html#selection-rectangle">Selection Rectangle"</A>
).  Then, use this command
to copy the selected data to the 'clipboard'.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> c</B></DD>
<DT><IMG SRC="fig-068.gif" WIDTH=36 HEIGHT=25><DT>
<DD> <B>Cut</B>
.  Operates just like the 
 <B>Copy</B>
 command, except that it also clears the
selection to the 'current color', which is set using the pixel measurement 
tool.
See "<A HREF="image-window.html#displaying-pixel-values">Displaying Pixel Values"</A>
 for further information.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> x</B></DD>
<DT><IMG SRC="fig-069.gif" WIDTH=36 HEIGHT=25></DT>
<DD> <B>Paste</B>
.  If there is no selection rectangle currently drawn, the first time you
issue the 
 <B>Paste</B>
 command, it will create a selection rectangle the size and shape
of the image data that will be pasted.  You may move and resize this 
rectangle
as you see fit (See "<A HREF="image-window.html#selection-rectangle">Selection Rectangle"</A>
).  Then, when you 
have
the selection appropriately adjusted, hit 
 <B>Paste</B>
 a second time to actually paste
the clipboard contents onto the image.</P>
<P>On the other hand, if you have a selection rectangle drawn when you hit 
 <B>Paste</B>
the first time, the image will be pasted into the selected area immediately.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> v</B>
</DD>
<DT><IMG SRC="fig-070.gif" WIDTH=36 HEIGHT=25></DT>
<DD> <B>Clear</B>
.  Clears the selected region to the 'current color', which is set using the
pixel measurement tool.  See "<A HREF="image-window.html#displaying-pixel-values">Displaying Pixel Values"</A>
.<BR>
Keyboard Equivalent:  
 <B>&lt;Meta> d</B>
</DD>
</DL>
<A NAME="pad-command"><H2>  The Pad Command</H2></A>
<P>The 
 <B>Pad</B>
 command is the opposite of the 
 <B>Crop</B>
 command.  Sort of.  It lets you add a border of a specified
size to the edges of the image.  It also lets you resize images to some 
desired size without manually
expanding or cropping the image.  But it goes further than that.  There are 
a whole slew of interesting
effects available, as described below:</P>
<IMG SRC="fig-071.gif" WIDTH=36 HEIGHT=25>
<P> <B>Pad</B>
.  Brings up the dialog box shown below.<BR>
Keyboard Equivalent:  
 <B>P</B></P>
<IMG SRC="fig-072.gif" WIDTH=494 HEIGHT=245>
<A NAME="pad-methods"><H3>  Pad Methods</H3></A>
<TABLE>
<TR>
<TD><IMG SRC="fig-074.gif" WIDTH=145 HEIGHT=52></TD>
<TD>
<P>There are three primary 
 <B>Pad</B>
 methods, as shown to the left.  These
methods are accessible via the 'Pad Method' menu, which says 'Solid
Fill' in the dialog box shown above.  In all cases, the 
 <B>Pad</B>
 command
operates in the same basic way:  A new image of the desired size is
created, it is filled as specified, and the original image is pasted onto 
this new image, centered.  If the new
image is smaller than the original image, the original image will be 
cropped.  Otherwise, the area outside
the original image will have the new background.</P>
</TD></TR>
</TABLE>
<P>Note:  The new, padded image will have the same 8/24-bit mode as the 
original.  As such, you  <I>probably</I>
want to switch to 
 <B>24-bit Mode</B>
  <I>before</I> issuing the 
 <B>Pad</B>
 command, particularly if you intend to modify the
image further.  (See "<A HREF="control-window.html#bit-menu">The 24/8 Bit Menu"</A>
.)</P>
<P>The 'Pad Method' menu gives you three different ways of filling the background:</P>
<DL>
<DT><IMG SRC="fig-073.gif" WIDTH=141 HEIGHT=16></DT>
<DD>
The background is filled with a solid color.  The color may be specified by
name, (as specified in the X11 '
 <TT>rgb.txt</TT>
' file), by RGB values in the range 0-
255, separated by commas (e.g. '0,255,128'), or by RGB values in hexadecimal
<P>(e.g. '0x00ff80').  In each case, the string you enter is parsed, and the
background is filled solid with the specified color.
</DD>
<DT><IMG SRC="fig-075.gif" WIDTH=141 HEIGHT=16></DT>
<DD>
The external program  <I>bggen</I> is executed to generate the background.  This
program is normally distributed with  <I>xv</I>, and  <I>xv</I> assumes that the executable 
is
located somewhere in your search path (such as '
 <TT>/usr/local/bin/bggen</TT>
').
 <I>bggen</I> can generate background gradients, at a specified angle.  The gradient
can be the entire size of the background, or it can repeat multiple times.  
See
"<A HREF="external-programs.html">External Programs"</A>
 for a complete description of the  <I>bggen</I>
command.
</DD>
<DT><IMG SRC="fig-076.gif" WIDTH=141 HEIGHT=16></DT>
<DD>
An image file in any of the  <I>xv</I>-supported formats may be loaded and used as 
the
background.  In this case, the background size (and therefore the size of 
the
padded image) is equal to the size of the loaded background image.  If you 
want
a different size, you can load the background image (as a regular image), 
resize
it as you see fit, save it, and use the newly saved version as the 
background for
the original image.
</DD>
</DL>
<A NAME="size-dials"><H3>  Image Size Dials</H3></A>
<IMG SRC="fig-077.gif" WIDTH=157 HEIGHT=123>
<P>These dials let you specify the size of the new, padded image in the
"Solid" and "Run 'bggen'" modes.  In the "Load Image" mode, the
dials are disabled, as the new image size is dictated by the size of the
loaded image.</P>
<P>If the image size dials are enabled, the small button above them resets
them to the size of the currently-loaded image.  Note that padding
with the 'new' size equal to the current size won't actually  <I>do</I>
anything, unless you change the "Opaque" dial, described below.</P>

<A NAME="opaque-ness"><H3>Opaque-ness</H3></A>
<P>This dial sets the 'opaque-itude' of the foreground (the original image).  
Normally,
this is set to '100%', which simply means that everywhere the original 
image and
the background overlap, the original image is what you'll see.  If you set 
the dial to
'0%', then wherever the original image and the background overlap, the 
background
is what you'll see.  In any case, at points where the foreground image does 
 <I>not</I>
overlap the background, you'll see the background, unmodified.  (Practical 
upshot:
at '0%' you will  <I>only</I> see the background.)</P>
<P>Of course, most of the interesting effects happen when the dial is set to 
intermediate values, where the
foreground image will appear semi-transparent.</P>
<P>There are four modes the 'Opaque' dial can operate in.  They are selected 
by clicking the button located
above the 'Opaque' dial.</P>
<A NAME="rgb"><H4>RGB</H4></A>
<IMG SRC="fig-078.gif" WIDTH=81 HEIGHT=123>
<P>
The two images are blended together in the most obvious way.  Each RGB color
component in the new image is computed by taking a weighted average of the
RGB components from the appropriate pixels in the foreground and
background images.  Like so:</P>
<P> <I>R</I>
 <I>new</I>
 <I> = </I>
(
 <I>opaque%</I>
  *  
 <I>R</I>
 <I>fg</I>
) + ( (100 - 
 <I>opaque%</I>
)  *  
 <I>R</I>
 <I>bg</I>
)
 <I>(same for G and B)</I>
</P>
<A NAME="int"><H4>INT</H4></A>
<P>
On overlapping pixels, only the  <I>Intensity</I> components (the 'V' in the HSV
colorspace, see "<A HREF="rgb-hsv-colorspaces.html">RGB &amp; HSV Colorspaces"</A>
) of the pixels are
blended, using the same weighted average calculation shown above.  If you 
set
the 'Opaque' value to '0%', brightness of overlapping pixels will be 
completely
determined by the 'background' pixel.  It's possible to get some interesting
'masking' effects and whatnot by playing around with black&amp;white
backgrounds.</P>
<A NAME="sat"><H4>SAT</H4></A>
<P>
Similar to 
 <B>INT</B>
, except that it is the  <I>Saturation</I> component (the 'S' in the HSV
colorspace, see "<A HREF="rgb-hsv-colorspaces.html">RGB &amp; HSV Colorspaces"</A>
) of the two pixels
that will be blended together, again using the weighted average calculation.
The effects possible with this one are considerably more subtle, and not
necessarily interesting.  It is mainly included for completeness.</P>
<A NAME="hue"><H4>HUE</H4></A>
<P>
In this case, the colors of the two overlapping pixels are blended.  You 
can get
some interesting effects by setting 'Opaque' to '0%', and loading a colorful
rainbow background.  In this case, at all overlapping pixels, it will be as 
if the
foreground image were a greyscale transparency, as the brightness and
saturation will be controlled by the foreground, and the color will be 
controlled
by the background.</P>
<P>Technical Note:  The 
 <B>HUE</B>
 case does  <I>not</I> simply do a weighted average of the
two hue components.  Instead, it plots the two points on the edge of a 
standard
color wheel, draws a straight line between them, and picks a point along 
this
line based on the 'Opaque' value (i.e., the larger the value, the closer it 
is to the
'foreground' endpoint of the line).  As a result, the 
 <B>HUE</B>
 setting can affect  <I>both</I>
the hue and saturation components of the computed pixel.  While this makes
this 'Opaque' mode somewhat unlike the others, once again it is a fine 
example
of xv's trademark "Do The Right Thing" technology.</P>
<A NAME="text-annotation"><H2>  Text Annotation</H2></A>
<P>Starting in  <I>xv</I> version 3.10, it is now possible to do  <I>text annotation</I>, or 
what we in the business call
"putting words on the picture".  There is one thing to note, before you go 
diving in:   <I>xv</I>'s text annotation
ability is Really Lame.  I mean,  <I>Big Time</I> Lame.  It's awkward to use (to 
say the least), and not very
powerful.  Frankly, it's an embarrassment.  But  <I>maybe</I>
 it'll be useful to someone.</P>
<P>Now that your expectations are suitably low, here's how it works:</P>
<IMG SRC="fig-079.gif" WIDTH=36 HEIGHT=25>

<P> <B>Text Annotation</B>
.  First, if you have a selection rectangle drawn, get rid of it.
Click this button to bring up a dialog box, where you can enter a 
single-line
string.  After you enter the string and press 
 <B>&lt;Return</B>
> (or the 
 <B>Ok</B>
 button in the
dialog box), you will be presented with an appropriately-sized selection
rectangle.  You may reposition and resize this rectangle as you see fit.  
When
you have the rectangle  <I>just so</I>, use the 
 <B>Paste</B>
 command to put the text on the
image.  The text will be pasted in the  <I>current color</I> (See "<A HREF="image-window.html#displaying-pixel-values">Displaying Pixel Values"</A>
).  The text will be stretched to fit the selection
rectangle.<BR>
Keyboard Equivalent: 
 <B>A</B></P>
<P>Note:  if you want to change the color of the pasted text, pick a new color 
(via the 'eyedropper'  described
in "<A HREF="image-window.html#displaying-pixel-values">Displaying Pixel Values"</A>
), and issue the 
 <B>Text Annotation</B>
 command again.  (It is not sufficient to simply 
 <B>Paste</B>
 again.)  Note that if you have a selection rectangle drawn, the 
 <B>Text Annotation</B>
command will not change the position or shape of the rectangle to reflect 
the new text, which lets you
easily re-
 <B>Paste</B>
 over your last attempt.</P>
<A NAME="grab-command"><H2>  The Grab Command</H2></A>
<IMG SRC="fig-080.gif" WIDTH=72 HEIGHT=25>
<P>The 
 <B>Grab</B>
 command in  <I>xv</I>
 version 3.10 has been extensively improved.  It is now possible to do 
 <I>delayed
grabs</I>
, which can give you time to shuffle some windows around before the grab takes place.  You can also
do  <I>delayed auto-grabs</I>
, which gives you a way to grab pull-down menus and other actions that take place
while a mouse-button is being held down.</P>

<P> <B>Grab</B>
 command.  Clicking this button brings up the  <I>xv grab</I> dialog box shown
(and described) below.<BR>
Keyboard Equivalent:  
 <B>&lt;Ctrl> g</B></P>
<IMG SRC="fig-081.gif" WIDTH=414 HEIGHT=200>
<P>A normal grab operation (issued by hitting the 
 <B>Grab</B>
 button in the  <I>xv grab</I> dialog box) operates as follows:</P>
<P>You can grab the entire contents of a window (including its frame) by 
clicking
the Left mouse button in a window.  If you click the Left button somewhere 
on
the root window, the entire screen will be loaded into  <I>xv</I>.  Note:  if you 
Left-
click somewhere inside a window whose contents are drawn in a different
visual than the frame (as happens on many 24-bit graphics systems, where the
default visual is an 8-bit PseudoColor, but the window contents may be drawn
in 24-bit TrueColor), the window frame will  <I>not</I> be included in the grabbed
image.  (It is not possible to grab data from two different visuals
simultaneously.)</P>
<P>You can grab an arbitrary region of the screen by clicking the Middle mouse
button and dragging a rectangle in exactly the same way you draw a cropping
rectangle.  When you release the mouse button, the contents of this 
rectangle
will be read from the screen and loaded into  <I>xv</I>.  Note:  the image will be
grabbed with respect to the visual of the outermost window that completely
encloses the grabbed rectangle.  (Practical upshot:  on 24-bit systems, if 
you try
to grab the contents of a 24-bit window, plus some of the (8-bit) root 
window,
window frames, etc., you will  <I>not</I> get what you probably wanted.  Sorry.) 
</P>
<P>Or, alternately, you can simply abort the 
 <B>Grab</B>
 command by clicking the Right
mouse button anywhere on the screen.</P>
<P>A  <I>delayed grab</I> is very similar to a normal grab, except that  <I>xv</I> will wait 
for the specfied number of
seconds, and then beep once to signify the start of the grab.  You can then 
press the Left, Middle, or Right
mouse buttons, as described above.  To do a delayed grab, simply enter a 
non-zero number in the 'Delay'
field, and press the 
 <B>Grab</B>
 button in the  <I>xv grab</I> dialog box.</P>
<P>A  <I>delayed auto-grab</I> is another matter entirely.  When you issue this 
command (by entering a non-zero
number in the 'Delay' field, and pressing the 
 <B>AutoGrab</B>
 button),  <I>xv</I> will sleep for the specified number of
seconds, and then  <I>automatically</I> grab the full contents of whatever 
top-level window the mouse is
positioned inside of.  This makes it possible to grab things like pull-down 
menus that cannot be captured
using the normal grab method.  For example, to grab a pull-down menu in 
another program, set the
'Delay' field to something small (say, '5' seconds), hit the 
 <B>AutoGrab</B>
 button, go to your other program,
and open up the pull-down menu.  Continue holding the menu open until  <I>xv</I> 
beeps once (signifying the
start of the grab), and then beeps twice (signifying the end of the grab).  
The entire top-level window
containing your menu will be copied into  <I>xv</I>.  If you get more than you 
want, you can easily crop off the
rest, using the cropping commands.  (See "<A HREF="image-window.html#cropping">Cropping"</A>
)</P>
<P>Note:  You may not be able to 
 <B>Grab</B>
 all of the  <I>xv</I> windows, at least not windows owned by the  <I>xv</I> doing the
grabbing.  If you run into this minor inconvenience, simply start a second 
copy of  <I>xv</I> and use it to grab the
windows from the first  <I>xv</I> (or vice-versa).</P>
<P>You can use the 
 <B>Grab</B>
 command for a wide variety of purposes.  For example, you can use it to 
print the
contents of any window (or the whole screen) by grabbing the appropriate 
image, and then saving it as a
PostScript file.</P>
<P>You can use the 
 <B>Grab</B>
 command, in conjunction with  <I>xv's</I> 
 <B>Zoom</B>
 and 
 <B>UnZoom</B>
 commands, as a
reasonable, albeit overpowered and none-too-quick, replacement for the  <I>xmag</I>
 program.</P>
<P>You can also use the 
 <B>Grab</B>
 command to pick 'just the right colors' for any application.  Simply start 
the
application in question, 
 <B>Grab</B>
 the window into  <I>xv</I>, and use the  <I>xv color editor</I> to twiddle the colors 
around
to your heart's content.</P>
<P>Note:  the 
 <B>Grab</B>
 command does not work on Macintoshes running  <I>MacX</I> in a 'rootless' mode, 
which isn't
too surprising, if you think about it...</P>

<A NAME="working-with-multiple-files"><H2>  Working With Multiple Files</H2></A>
<P> <I>xv</I> provides a set of controls that let you conveniently operate on a list 
of images.  To use the following
commands, you'll have to start up  <I>xv</I> with a list of filenames.  For 
example, you could type '
 <TT>xv *.gif</TT>
'
(assuming, of course, that you have a bunch of files that end with the suffix '.gif' in the current directory).
</P>
<P>The filenames are listed in a scrollable window, as shown below.  The 
current selection is shown in
reverse video.  If there are more names than will fit in the window, the scrollbar will be enabled.</P>
<IMG SRC="fig-082.gif" WIDTH=434 HEIGHT=186>

<A NAME="operating-list-window"><H3>  Operating a List Window</H3></A>
<P>The scrollbar operates as follows:</P>
<UL>
<LI>clicking in the top or bottom arrow of the scrollbar scrolls the list by 
one line in the appropriate
direction.  It will continue to scroll the list as long as you hold the mouse down.</LI>
<LI>The thumb (the small rectangle in the middle of the scrollbar) shows 
roughly where in the list
you are.  You can change your position in the list by clicking and dragging 
the thumb to another
position in the scrollbar.  The list will scroll around as you move the thumb.</LI>
<LI>You can scroll the list up or down a page at a time by clicking in the grey 
region between the
thumb and the top or bottom arrows.</LI>
<LI>If you click on a name in the list, that name will become highlighted.  You can drag 
the highlight
bar up and down, and the list will scroll appropriately.</LI>
<LI>It is also possible to control the list window from the keyboard.  In all 
cases, you must make sure
that the window sees the keypress.  Generally, this means you have to have 
the cursor inside the
window, though your window manager may also require you to click inside the window first.</LI>
<LI>The up and down arrow keys move the highlight bar up and down.  If the bar 
is at the top or
bottom of the window, the list will scroll one line.</LI>
<LI>The 
 <B>&lt;PageUp></B>
 and 
 <B>&lt;PageDown></B>
 keys scroll the list up or down a page at a time.  These keys
may be called 
 <B>&lt;Previous></B>
 and 
 <B>&lt;Next></B>
 on your keyboard.  You can probably also page up and
down by typing 
 <B>&lt;shift>-&lt;Up></B>
 and 
 <B>&lt;shift>-&lt;Down></B>
.</LI>
<LI>Pressing the 
 <B>&lt;Home> </B>
key will jump to the beginning of the list.  Pressing the 
 <B>&lt;End></B>
 key will
jump to the bottom of the list.  If you don't have 
 <B>&lt;Home> </B>
and 
 <B>&lt;End></B>
 keys on your keyboard,
you may be able to emulate them by holding 
 <B>&lt;shift></B>
 and typing the 
 <B>&lt;PageUp></B>
 and
 <B>&lt;PageDown></B>
 keys.</LI>
</UL>

<A NAME="file-commands"><H3>  The File Commands</H3></A>
<P>You can directly view any image in the list by double-clicking on its 
filename.  If  <I>xv</I> is unable to load the
file (for any of a variety of reasons), it'll display an appropriate error message.</P>
<DT><IMG SRC="fig-083.gif" WIDTH=72 HEIGHT=22></DT>
<DD>
<P>Attempts to load the next file in the list.  If it is unable to load the 
next file, it
will continue down the list until it successfully loads a file.  If it gets 
to the bottom of the list without successfully loading a file, it will put up
 the default image.<BR>
Keyboard Equivalent: 
 <B>&lt;Space></P>
</DD>
<DT><IMG SRC="fig-084.gif" WIDTH=72 HEIGHT=22></DT>
</B></P><DD>
<P>Attempts to load the previous file in the list.  If it is unable to load 
the previous
file, it will continue up the list until it successfully loads a file.  If 
it gets to the
top of the list without successfully loading a file, it will put up the 
default
image.<BR>
Keyboard Equivalent: 
 <B>&lt;backspace></P>
</DD>
<DT><IMG SRC="fig-085.gif" WIDTH=72 HEIGHT=22></DT>
</B></P><DD>
<P>This command lets you delete the currently selected file from the list (and
optionally delete the associated disk file).  Note that the currently selected file 
is
the one with the highlight bar on it.  While this is generally the same as 
the
currently displayed image, it doesn't have to be.<BR>
Keyboard Equivalent: 
 <B>&lt;Ctrl> d</B></P>
<P>The 
 <B>Delete</B>
 command will pop up a window asking you what you want to
delete.  Your choices are:</P>
<UL>
<LI>List Entry</B>
, which will remove the highlighted name from the list.  (Keyboard
Equivalent: 
 <B>&lt;Enter></B>
)</LI>
<LI>Disk File</B>
, which will remove the highlighted name from the list and also delete
the associated disk file.  This removes unwanted images, just like manually
typing '
 <TT>rm &lt;filename></TT>
' in another window.  (Keyboard Equivalent:
 <B>&lt;Ctrl> d</B>
)</LI>
<LI>Cancel</B>
, which lets you get out of the 
 <B>Delete</B>
 command without actually
deleting anything.  (Keyboard Equivalent: 
 <B>&lt;Esc></LI>
</UL>
<P>
</DD>
<DT><IMG SRC="fig-086.gif" WIDTH=72 HEIGHT=22></DT>
</B></P><DD>
<P>Opens the  <I>xv load</I> window, which lets you load images that weren't specified
on the original command-line.  See "<A HREF="load-window.html">The Load Window"</A>
 for more
details. Note:  this function has been mostly taken over by the  <I>visual 
schnauzer</I>
(See "<A HREF="visual-schnauzer.html">The Visual Schnauzer"</A>
) but remains for largely historical
reasons.  (It  <I>is</I> considerably faster than the  <I>schnauzer</I>, however...)<BR>
Keyboard Equivalent: 
 <B>&lt;Ctrl> l</P>
</DD>
<DT><IMG SRC="fig-087.gif" WIDTH=72 HEIGHT=22></DT>
</B></P><DD>
<P>Opens the  <I>xv save</I> window, which lets you save the current image (or current
selected area) in a variety of image formats.  See "<A HREF="save-window.html">The Save
Window"</A>
 for more details.<BR>
Keyboard Equivalent: 
 <B>&lt;Ctrl> s</B>
</P>
</DD>
<DT><IMG SRC="fig-088.gif" WIDTH=72 HEIGHT=22></DT>
<DD>
<P>Prints the current image to a PostScript
2
 device..  This command takes a
somewhat Unix-centric approach to printing, but it may work on other
operating systems.  When you issue this command, it opens a dialog box which
prompts you for the 'print' command to use.  Normally, this is just '
 <TT>lpr</TT>
', but if
you'd like to send the output to another printer, you could use something 
like
'
 <TT>lpr -Pelsewhere</TT>
'.  (And right after you do that, you should change the
name of that printer!)  You change the default command the appears in this
window by using the '
 <TT>xv.print</TT>
' X resource.  See "<A HREF="modifying-behavior.html#resources">Other
Resources"</A>
.</P>
<P>Anyway, enter some command that will have the desired effect.   <I>xv</I> will open
up the  <I>xv postscript</I> window, where you can fine-tune the size, position, and
rotation of your image. See "<A HREF="postscript-window.html">The PostScript Window"</A>
 for more
information.  When you press the 
 <B>Ok</B>
 button,  <I>xv</I> will generate the appropriate
PostScript, and feed it as '
 <TT>stdin</TT>
' to the command you entered earlier.<BR>
Keyboard Equivalent: 
 <B>&lt;Ctrl> p</B></P>
</DD>
</DL>
<A NAME="reloading"><H3>  Image Reloading</H3></A>
<P>It is occasionally desirable to reload an image file because the contents 
of the file have changed.  For
example, you could be downloading a file, and you might want to keep 
reloading the file to check on the
progress of the download.  Or perhaps you have a program that generates 
images, and you'd like to view
these images without any manual intervention.</P>
<P> <I>xv</I>
 provides a way to reload an image via an external signal.  If you send the 
 <I>xv</I> process a 
 <TT>SIGQUIT</TT>
 signal
('
 <TT>kill -QUIT </TT>
 <TT>&lt;pid></TT>
', or '
 <TT>kill -3 </TT>
 <TT>&lt;pid></TT>
' on most systems), the program will reload the
currently selected file.  (The one that is currently highlighted in the  <I>xv 
controls</I> window filename list.)
This behavior is exactly the same as hitting 
 <B>&lt;Return></B>
 in the  <I>xv controls</I> window.  If  <I>xv</I> is currently in a
state where hitting 
 <B>&lt;Return></B>
 in the controls window won't load an image (i.e., some pop-up dialog box is
grabbing all such events), then sending this signal won't work either.</P>
<P>An idea:  You could write a 'clock' program that, once a minute, generates 
a really spiffy looking picture
of the current time (with color gradations, 3-d extruded numbers, 
whatever), then sends  <I>xv</I> the signal to
reload the generated image.  If anyone ever does this, I'd like to hear about it.</P>
<P>Note:  This will not work if the current file was read from 
 <TT>&lt;stdin></TT>
.</P>
<P> <I>xv</I> also has a 'polling mode', enabled by the '
 <TT>-poll</TT>
' option.  When it is turned on,  <I>xv</I> will attempt to
recognize when the currently displayed file changes on disk.  (What with 
UNIX being a multi-tasking OS,
it's perfectly possible to have another process modify a file while  <I>xv</I> is 
displaying it.)  When the current
file changes,  <I>xv</I> will reload it.</P>
<P>You can use this feature to get  <I>xv</I> to monitor all sorts of things.  For 
example, if you have one of those
programs that automatically goes out and  <I>ftps</I> the latest version of the US 
weather map, (and you do, in
the 
 <TT>unsupt</TT>
 directory), then you can have  <I>xv</I> automatically reload the map whenever a 
new one is
downloaded.</P>
<P>                                                       </P>
<P>It probably goes without saying that 'PostScript' is a registered trademark of Adobe Systems, Inc.
</P>
<P>You could even use  <I>xv</I> as a sort of frame buffer, to allow otherwise non-X 
programs to display graphics.
Just have your program draw on its own internal 'frame buffer' (just an 
appropriately sized hunk of
memory), and periodically write it out to a file in some  <I>xv</I>-supported 
format.  The PBM/PGM/PPM
formats are trivial to write.  See the documentation in the 
 <TT>doc</TT>
 subdirectory of the  <I>xv</I> distribution.
Anyhow, periodically write the image to a file, and have  <I>xv</I> display the 
file with the '
 <TT>-poll</TT>
' option
turned on.  Voila!  An instant output-only frame buffer for X workstations, albeit a fairly slow one.</P>
<A NAME="windows-menu"><H2>  The Windows Menu</H2></A>
<IMG SRC="fig-093.gif" WIDTH=138 HEIGHT=153>
<P>As an obvious result of  <I>xv</I>'s patented "Keep-Adding-Code-Until-It-
Breaks" Technology, there are considerably more commands, features,
cool gizmos, and dubious design decisions than will comfortably fit in the
 <I>xv controls</I> window.</P>
<P>Luckily, this is nothing that bolting-on a couple more top-level windows
won't fix, which is the method that has been used.</P>
<P>This is where the 
 <B>Windows </B>
 menu comes into play, though in practice
you'll probably just use the keyboard equivalents to open the other
windows.  I know  <I>I</I> do.</P>
<DL>
<DT><IMG SRC="fig-089.gif" WIDTH=134 HEIGHT=16></DT>
<DD>
<P>Opens up a  <I>xv visual schnauzer</I>
 window (you can have up to four of them).  The
 <I>visual schnauzer</I> lets you manipulate your image file collection in a nifty
Point'n'Click, Drag'n'Drop, What You See Is What You Get, Graphical User
Interface.  Despite all that, it's actually a useful thing.  See "<A HREF="visual-schnauzer.html">The
Visual Schnauzer"</A>
 for more info.<BR>
Keyboard Equivalent:  
 <B>&lt;Ctrl> v</P>
</DD>
<DT><IMG SRC="fig-090.gif" WIDTH=134 HEIGHT=16></DT>
</B></P><DD>
<P>Opens and closes the  <I>xv color editor</I> window.  The  <I>color editor</I> provides you
with an interesting collection of color manipulation doodads, including a
colormap editor, hue remapping controls, arbitrary R, G, B, and I gamma
correction curves, and so on.  See "<A HREF="color-editor.html">The Color Editor
"</A>
 for more info.<BR>
Keyboard Equivalent:  
 <B>e</P>
</DD>
<DT><IMG SRC="fig-091.gif" WIDTH=134 HEIGHT=16></DT>
</B></P><DD>
<P>Opens and closes the  <I>xv info</I> window.  This window gives you detailed
information about the current image, the current selection, the 
success/failure
of the color allocation code, and such.  See "<A HREF="info-window.html">The Info Window"</A>
 
for
more info.<BR>
Keyboard Equivalent:  
 <B>I</P>
</DD>
<DT><IMG SRC="fig-092.gif" WIDTH=134 HEIGHT=16></DT>
</B></P><DD>
<P>Opens the  <I>xv image comments</I> window.  This lets you view any comments that
may be encoded in the current image.  It does  <I>not</I> let you add or edit any
comments, as that's a project for a later release.  Note that, currently, 
the vast
majority of images do  <I>not</I> have comments in them.  My fault, no doubt.  See
"<A HREF="textview-window.html#comment-window">The Comment Window"</A>
 for more details.<BR>
Keyboard Equivalent:  
 <B>&lt;Ctrl> c</B></P>
</DD>
<DT><IMG SRC="fig-094.gif" WIDTH=134 HEIGHT=16></DT>
<DD>
<P>Opens the  <I>xv text viewer</I> window.  Displays the contents of the currently
selected file (i.e., the file selected in the filename list in the  <I>xv 
controls</I>
window), as ASCII text, or as a hexadecimal dump.  This happens
automatically when  <I>xv</I> tries to load a file in a format it doesn't 
recognize.  See
"<A HREF="textview-window.html">The TextView Window"</A>
 for more info.<BR>
Keyboard Equivalent:  
 <B>&lt;Ctrl> t</P>
</DD>
<DT><IMG SRC="fig-095.gif" WIDTH=134 HEIGHT=16></DT>
</B></P><DD>
<P>Opens the  <I>xv text viewer</I> window, and displays version information, copyright
notice, licensing information, the author's email addresses, and such.
Basically, it's the text of the first two (or so) pages of this manual.<BR>
Keyboard Equivalent:  
 <B>&lt;Ctrl> a</P>
</DD>
<DT><IMG SRC="fig-096.gif" WIDTH=134 HEIGHT=16></DT>
</B></P><DD>
<P>Opens the  <I>xv text viewer</I> window, and displays a summary of all the keyboard
equivalents and mouse button permutations.</P>
</DD>
</DL>
<A NAME="commands"><H2>  Other Commands</H2></A>
<DL>
<DT><IMG SRC="fig-097.gif" WIDTH=72 HEIGHT=25></DT>
</B></P><DD>
<P>Does exactly the same thing as the 
 <B>About XV</B>
 command described in "<A HREF="control-window.html#windows-menu">The Windows Menu"</A>
:  displays version number, licensing info, etc.</P>
</DD>
<DT><IMG SRC="fig-098.gif" WIDTH=83 HEIGHT=41></DT>
<DD>
<P>'Reloads' and displays the  <I>xv logo</I> image, which not only contains the 
version
number and revision date of this copy, it  <I>also </I>has some nifty 3-D fish.</P>
<P>The logo image also displays who, if anyone, this particular copy of  <I>xv</I> is
licensed to.  If it still says "UNREGISTERED COPY", you should probably do
something about that.<BR>
Keyboard Equivalent:  &lt;none whatsoever></P>
</DD>
<DT><IMG SRC="fig-099.gif" WIDTH=72 HEIGHT=25></DT>
<DD>
<P>Quits  <I>xv</I>.  Quite possibly the most useful command of them all.<BR>
Keyboard Equivalents:  
 <B>q</B>
 and 
 <B>&lt;Ctrl> q</B></P>
</DD>
</DL>
<HR>
This document was extracted from the PostScript documentation and
formatted by <A HREF="mailto:rjohnson@shell.com">Roy Johnson</A>.
Much of the process was automated, and may therefore have introduced
errors.  Corrections are appreciated.

</BODY></HTML>
