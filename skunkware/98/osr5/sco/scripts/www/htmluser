#!/usr/local/bin/gawk -f
# @(#) htmluser.awk 3.1 97/07/15
# 94/03/22 John H. DuBois III (john@armory.com)
# 94/03/31 Deal with an odd number of finger files, and ignore 0-length files.
# 95/06/02 Write to cache file if requested.
# 95/09/05 Generalized from htmlfinger; added all options;
#          convert to awk script.
# 95/09/07 Added l option.
# 96/07/20 Print letter banner for quick access.
# 96/11/12 Added d option; made it be off by default.
# 97/03/01 Use config file.
# 97/05/12 Added T option (table support).
# 97/05/24 Added timezone to 'list last built' date; added r option;
#          make cache tempfile have PID extension.
# 97/05/26 Split help printf for non-GNU awk; mangle - to + in help if needed;
#          added _strftime() for non-gawk portability.
# 97/07/15 3.1 Emit Expires: field.

# Porting:
# This program works under SCO UNIX.  It will likely need tweaking on other
# systems.  If the awk part does not work with your awk, try gawk.
# Any non-GNU awk will likely need to have the '_strftime' function at the
# end of this program renamed to 'strftime'.
# On systems that have a fingerd that runs as root (so it can read any .plan
# file regardless of ownership/perms), change the [ -r $home/$file ] test
# to [ -f $home/$file ].  That still will not find finger files in
# non-executable home dirs, which a root fingerd could find.  Also, it will
# be incorrect for files other than finger files (web pages, etc).
# If finger files are named something other than .plan (e.g. .usrrc), change
# that.
# The FTP testfile and URL will have to be changed to reflect where user
# anonymous FTP dirs are kept.
# If the GCOS (comment) field in /etc/passwd contains something other than
# user name[,office] it will have to be dealt with.

# The http URLs intentionally do not include a hostname,
# so that the hostname from the page this is found on will be used,
# since it might be different than the hostname given for the finger address.

BEGIN {
    Err = 0
    Name = "htmluser"
    rcFile = "/etc/default/" Name
    Usage = "Usage: " Name " [-dhlpwtNT] [-n<hostname>] [-u<userlist>]\n"\
"                [-r<trailer-file>] [-e<expire-time>] [cachefile]"
    ARGC = Opts(Name,Usage,"n:ptu:dr:wTe#hlx",0,rcFile,
    "HOSTNAME,FINGER,FTP,USERS,ALLUSERS,TRAILER,WEB,TABLES",1,"N")
    Debug = "x" in Options
    # BadFiles: Files that hold the names of users whose files s/b ignored
    # TestFiles: Names of files to check for.  If path does not start with /,
    # it is taken to be relative to user's home dir; if it does, /username
    # is attached to the end.
    # URLs: URL to access user's files.  User name is substituted for %s,
    # Host name is substituted for HOSTNAME.
    # TypeNames: The "long names" used to build selectable fields.  If the
    # lines end up being too long, these are shorted to their first word.
    TypeInfo("finger",BadFiles,TestFiles,URLs,TypeNames,
    "/usr/local/lib/ignorefinger,.plan,http:/cgi-bin/fing?%s,finger file")
    TypeInfo("web",BadFiles,TestFiles,URLs,TypeNames,
    "/usr/local/lib/ignorepages,.public_html/index.html,http:/~%s/,web page")
    # FTP: does not pick up a hostname relative to the page being read
    TypeInfo("ftp",BadFiles,TestFiles,URLs,TypeNames,
"/usr/local/lib/ignoreftp,/usr/local/ftp/pub/user,ftp://HOSTNAME/pub/user/%s,FTP dir")
    # The order to list info in the html page
    split("web,finger,ftp",InfoOrder,",")
    if ("h" in Options) {
	print mangleHelp(sprintf(\
"%s: build an HTML file listing all users with finger files, web pages, or\n"\
"anonymous FTP directories.\n"\
"%s\n"\
"This program finds all user names and home directories by reading\n"\
"/etc/passwd, and checks each for the existance and readability of a %s or a\n"\
"%s file.  It also looks for a directory with the user's\n"\
"name in %s.  If there are finger files, web pages, or\n"\
"anonymous FTP directories that should be ignored for whatever reason (e.g.,\n"\
"those with 100K character long lines, which chokes some browsers), put them\n"\
"in %s, %s, or %s\n"\
"respectively, one per line, and make the file readable.  The finger URLs\n"\
"produced by %s depend on the existence of a cgi finger program accessible\n"\
"through the URL /cgi-bin/fing.  %s can either be called directly as a\n"\
"cgi-bin program, or can be run at regular intervals to build a cache file\n"\
"that is referenced via URL.  The latter is a better option if you find\n"\
"that running this program takes a long time, as it probably will if there\n"\
"are a lot of users on the system it is run on, since it has to check every\n"\
"user's home directory for the existence of finger files and web pages.  If\n"\
"it is run regularly, it should be run with approximately the same level of\n"\
"authorization that fingerd, httpd, and FTP run with, so it will find only\n"\
"the files that those daemons will be able to access.  Running it as nouser\n"\
"is often good enough, as long as nouser can access the anonymous FTP\n"\
"directories using a local pathname.\n"\
"If the name of a cache file is supplied on the command line, the output is\n"\
"first stored in a file of the same name but with a '-' attached, and is\n"\
"then moved to the cache file name, in order to minimize the time during\n"\
"which the file contents are not available.  The directory that the cache\n"\
"file is in must be writable by the process.",
    Name,Usage,TestFiles["finger"],TestFiles["web"],TestFiles["ftp"],
    BadFiles["finger"],BadFiles["web"],BadFiles["ftp"],Name,Name),"\n[")
    print mangleHelp(sprintf(\
"Options:\n"\
"Some of the following options can also be set by assigning values to\n"\
"variables in a configuration file named %s.  Variables are\n"\
"assigned to with the syntax:  varname=value  or in the case of flags, by\n"\
"simply putting the indicated variable name in the file without a value.\n"\
"Options given on the command line override assigments in the configuration\n"\
"file.  Flag options set in the configuration file can be turned off on the\n"\
"command line by following them immediately with \"-\", e.g. -v- to turn\n"\
"off the v option in such a way that it cannot be turned on in the config\n"\
"file.  Variable names appear in parentheses in the option descriptions.\n"\
"\n"\
"The following three options determine what types of user-presented\n"\
"information are searched for and included in the output.  If none are\n"\
"selected, all are included.  If any are given in the command line, any\n"\
"values given in the configuration file are ignored.\n"\
"-p: Include finger files (.plans) in the output.  (FINGER)\n"\
"-w: Include web pages in the output.  (WEB)\n"\
"-t: Include anonymous FTP directories in the output.  (FTP)\n"\
"Other options:\n"\
"-h: Print this help.\n"\
"-n<hostname>: Set the hostname used in text and for the FTP host name.\n"\
"    The HTTP URL hostname is left relative to the output page.  The default\n"\
"    is to use the output of the \"hostname\" command.  (HOSTNAME)\n"\
"-u<userlist>: Process only the users given in the comma-separated list.\n"\
"    (USERS)\n"\
"-d: Normally, files in a particular home directory will only be listed\n"\
"    for the first user who has that home directory.  -d causes them to be\n"\
"    listed for all users who have each home directory.  (ALLUSERS)\n"\
"-l: Generate a logged-in users report, listing various information about\n"\
"    the users currently logged into the system (similar to what 'who'\n"\
"    prints), along with links for the information that those users have\n"\
"    available.\n"\
"-r<trailer-file>: Insert the contents of <trailer-file> into the output\n"\
"    after all other body contents have been emitted, just before the\n"\
"    </body> tag.(TRAILER)\n"\
"-e<expire-time>: If output is not being cached in a file, an Expires:\n"\
"    field is emitted.  By default, the expiration time for a logged-in\n"\
"    users reports is one minute in the future, and for the normal output\n"\
"    is one day in the future.  -e can be used to set the expire time\n"\
"    explicitly to <expire-time> seconds in the future.  Use a value of -1\n"\
"    to not emit an Expires: header.\n"\
"-T: Use HTML tables in output.\n"\
"-N: Do not read the configuration file.",rcFile)," \n")
	exit 0
    }
    multiDirs = "d" in Options
    useTables = "T" in Options
    if ("r" in Options)
	trailerFile = Options["r"]
    # If any of pwt given on comman line, ignore any set in config file.
    ArgsOnly = OptsGiven(Options,"pwt",1,0,0)
    if (OptsGiven(Options,"p",ArgsOnly,0,0)) {
	DoI[IndToDo = "finger"]
	NTypes++
    }
    if (OptsGiven(Options,"w",ArgsOnly,0,0)) {
	DoI[IndToDo = "web"]
	NTypes++
    }
    if (OptsGiven(Options,"t",ArgsOnly,0,0)) {
	DoI[IndToDo = "ftp"]
	NTypes++
    }
    if (NTypes == 0) { # By default, do all.
	for (i = 1; i in InfoOrder; i++)
	    DoI[InfoOrder[i]]
	NTypes = i-1
    }
    if ("n" in Options)
	HostName = Options["n"]
    else {
	if (CmdReadLine("exec /usr/bin/hostname",1) != 1)
	    exit 1
	HostName = $0
    }


    if (DoLoggedIn = ("l" in Options)) {
	GoodUsers = DoWho(ExtraInfo)
	# Make sure we get all names from /etc/passwd, even for users who
	# have no files
	AllNames = "	echo \"$user:$name\"\n"\
    }
    else if (UserListGiven = ("u" in Options)) {
	# Test for good user before testing user files, so that this program
	# will be faster if a user list is given
	GoodUsers = Options["u"]
	# Make sure the result will be a good ksh expression
	gsub("[^-a-z0-9_,]","",GoodUsers)
	gsub(",","|",GoodUsers)
    }
    else
	for (i in DoI)
	    if (BadFiles[i] != "") {
		while ((ret = (getline < BadFiles[i])) == 1)
		    if (NF == 1 && $1 !~ /^#/)
			BadUsers[$1,i]
		close(BadFiles[i])
		if (Debug && ret == 0)
		    printf "Found/read %s badusers list.\n",i > "/dev/stderr"
	    }
    if (GoodUsers != "")
	GoodUsers = "    [[ \"$user\" = @(" GoodUsers ") ]] || continue\n"
    for (i in DoI) {
	testList = testList TestFiles[i] " " i " "
	gsub("HOSTNAME",HostName,URLs[i])
	TypesLen += length(TypeNames[i]) + 2
    }
    # Keep line length < 80 cols for the sake of users using lynx.
    # If doing logged-in users report, there about ScreenFree colums left
    # for the info list.
    MaxLen = 26	# Maximum length a name is allowed to be
    if (DoLoggedIn && TypesLen > (ScreenFree = 19)) {
	TypesLen = 0
	for (i in DoI) {
	    sub(" .*","",TypeNames[i])
	    TypesLen += length(TypeNames[i]) + 2
	}
	if (TypesLen > ScreenFree)
	    MaxLen -= TypesLen - ScreenFree
    }
    if (Debug)
	printf "Types length: %d; screen free: %d; max name length: %d\n",
	TypesLen,ScreenFree,MaxLen> "/dev/stderr"
    # Get list of all particular files that exist for users who meet criteria.
    # Output has the form: username:gcos-field:file-type-index:file
    # where file is the filename if the file is in a user's home dir, else null
    Cmd = \
"exec /bin/ksh -c '\n"\
"print $PPID\n"\
"IFS=:\n"\
"typeset -i i\n"\
"while read user a b c name home d; do\n"\
GoodUsers \
"    set -- " testList "\n"\
"    while [ $# -gt 0 ]; do\n"\
"	if [[ \"$1\" != /* ]]; then\n"\
"	    file=$home/$1\n"\
"           fhome=$file\n"\
"	else\n"\
"	    file=$1/$user\n"\
"           fhome=\n"\
"	fi\n"\
"	index=$2\n"\
"	shift 2\n"\
"	[ -r $file -a -s $file ] && echo \"$user:$name:$index:$fhome\"\n"\
AllNames \
"    done\n"\
"done;:' < /etc/passwd"

    if (Debug)
	printf "Issuing command:\n%s\n",Cmd > "/dev/stderr"
    if ((Cmd | getline PID) != 1) {
	print Name ": Error running ksh.  Aborting." > "/dev/stderr"
	exit 1
    }

    if (ARGC > 1) {
	Cache = ARGV[1]
	OutFile = Cache "." PID
    }
    else
	OutFile = "/dev/stdout"
    if (Debug)
	print "Output file is " OutFile > "/dev/stderr"
    # Print first lines of header to test whether we can write cache file.
    # awk/gawk will abort if the redirection fails.
    # If output is read directly, it should include Content-type; if it is
    # stored in a file, it should not.
    if (Cache == "") {
	if ("e" in Options)
	    expireTime = Options["e"]
	else if (DoLoggedIn)
	    expireTime = 60
	else
	    expireTime = 86400
	printf "Content-type: text/html\n" > OutFile
	if (expireTime == -1)
	    print "" > OutFile
	else
	    printf "Expires: %s GMT\n\n",
	    strftime_gmt("%a, %d %b %Y %T",systime()+expireTime) > OutFile
    }
    print "<head>" > OutFile

    FS = ":"
    while ((Cmd | getline) == 1)
	ProcLine(multiDirs)
    fileCheckRet = close(Cmd)
    # Must sort *after* ProcLine() because elimination of dup dirs depends on
    # original order of /etc/passwd
    GoodCt = qsortByArbIndex(UsersFound,Users,0)
	
   Letters = GetInitLetters(Users,GoodCt)

    if (!DoLoggedIn && NTypes == 1)
	DoOne(Letters)
    else
	DoMany(Letters)

    if (Cache != "")
	printf "<hr><i>List last built: %s</i>\n",
	strftime("%a %h %d %H:%M %Z") > OutFile
    if (trailerFile) {
	while ((ret = (getline < trailerFile)) == 1)
	    print $0 > OutFile
	if (ret) {
	    printf "Error reading trailer file %s\n",
	    trailerFile > "/dev/stderr"
	    Err = 1
	}
    }
    print "</body>" > OutFile
    if (Cache != "") {
	if (Err)
	    print "Cache file not updated." > "/dev/stderr"
	else {
	    Cmd = sprintf("chmod a+r %s && mv -f %s %s",OutFile,OutFile,Cache)
	    if (Debug)
		print "Running: " Cmd > "/dev/stderr"
	    system(Cmd)
	}
    }

    exit Err
}

# Gather information about logged-in users from 'who'.
# For each logged-in user, ExtraInfo[user] is set to a string describing
# information about that user's login session.
# Return value: a regular expression of the form user1|user2|...
# Globals: Sets ExtraHeader to a string suitable for using as a header for
# the information about users returned in ExtraInfo[].
function DoWho(ExtraInfo,  Cmd,Format,user,writable,tty,date,idle,UserPat) {
# who -uT output looks like this:
# spcecdt  + ttyp13       Sep 03 20:09  1:10   4959

    Header = \
"<title>Users on " HostName "</title></head>\n"\
"<body><h1>Users on " HostName " at " strftime("%H:%M %Z %a %b %d") "</h1>\n"\
"<br>Multiple instances of a user name usually refer to a single user who "\
"has logged in multiple times.\n"\
"A <b>+</b> in the <i>W</i> column usually indicates that the user is "\
"talkable, as <i>user</i><b>@" HostName "</b>\n"\
"Select the user's login name to send mail to the user.\n"\
"Selectable fields on the right access various types of public information "\
"maintained by the user.\n"
    Cmd = "exec /bin/who -uT"
    if (useTables)
	Format = "<td>%-12.12s</td><td>%5.5s</td><td>%-4.4s</td><td>%s</td>"
    else
	Format = "%-12.12s %5.5s %-4.4s %s"
    if (useTables)
	ExtraHeader = "<th>Login@</th><th>Idle</th><th>TTY</th><th>W</th>"
    else
	ExtraHeader = \
	sprintf(Format " %-8s %s","Login@ (" strftime("%Z") ")","Idle","TTY",
	"W","User","Name")
    while ((Cmd | getline) == 1) {
	user = $1
	writable = $2
	tty = $3
	sub("^tty","",tty)
	date = $4 " " $5 " " $6
	idle = $7
	if (idle == "old")
	    idle = ">24h"
	else if (idle == ".")
	    idle = ""
	ExtraInfo[user] = \
	sprintf(Format, date, idle, tty, writable == "+" ? "+" : " ")
	if (UserPat != "")
	    UserPat = UserPat "|" user
	else
	    UserPat = user
    }
    close (Cmd)
    return UserPat
}

# Globals:
# InfoOrder[1..n] holds the order in which info should be listed.
# ExtraInfo[] holds information on the login sessions of logged-in users if
# -l was given.
# NTypes is the number of types of information to be displayed.
function DoMany(Letters,
User,Dots,i,j,Order,ind,HighestFound,l,s,last,Name) {
    for (i = 1; i in InfoOrder; i++)
	if ((ind = InfoOrder[i]) in DoI) {
	    Dots[ind] = TypeNames[ind]
	    gsub(".",".",Dots[ind])
	    Order[++j] = ind
	}

    # Only center if using tables; if not, lines are different lengths
    # Oops... NS 3.0 doesn't center tables
#    if (useTables)
#	print "<center>" > OutFile
    if (Header)
	print Header > OutFile
    else
	printf \
"<title>%s user-presented information</title></head><body><p>\n"\
"<h1>%s user-presented information<br>Current presenter count: %d</h1><p>\n"\
"<h2>Select the information you wish to access.\n"\
"</h2>\n", HostName,HostName,GoodCt > OutFile

    if (ExtraHeader == "" && Letters != "")
	print Letters "\n" > OutFile
    if (!useTables) {
	print "<pre>" > OutFile		# must do this before printinger
	if (ExtraHeader != "")
	    print ExtraHeader > OutFile
    }

    if (useTables)
	printf \
"<table border=1 cellspacing=0 cellpadding=2>\n"\
"<tr>%s<th>User</th><th>Name</th><th colspan=" NTypes \
">Information Type</th></tr>\n",ExtraHeader > OutFile

    for (i = 1; i <= GoodCt; i++) {
	User = Users[i]
	# Determine how far to draw dots
	for (j = NTypes; j >= 1; j--)
	    if ((User,Order[j]) in TypesFound)
		break
	HighestFound = j

	if (useTables)
	    printf "<tr>" > OutFile
	if (User in ExtraInfo)
	    printf "%s ",ExtraInfo[User] > OutFile
	# Mosaic won't let this stand by itself
	if (!ExtraHeader && (l = substr(User,1,1)) != last) {
	    Name = "name=" l " "
	    last = l
	}
	else
	    Name = ""
	# Print login name
	if (useTables)
	    printf "<td>" > OutFile
	printf "<a %shref=mailto:%s@%s>%s</a>",Name,User,HostName,User > OutFile
	if (useTables)
	    printf "</td><td>" > OutFile
	else
	    printf "%s ",substr("       ",length(User)) > OutFile
	# Print real name
	printf "%s",Names[User] > OutFile
	if (useTables)
	    printf "</td>" > OutFile
	else
	    printf "%s",HighestFound ? \
	    substr(" .......................",1,MaxLen - length(Names[User])) \
	    : "" > OutFile
	for (j = 1; j <= HighestFound; j++) {
	    ind = Order[j]
	    if ((User,ind) in TypesFound) {
		if (useTables)
		    printf "<td>" > OutFile
		printf " <a href=" URLs[ind] ">%s</a>",
		User,TypeNames[ind] > OutFile
		if (useTables)
		    printf "</td>" > OutFile
		else
		    printf " " > OutFile
	    }
	    else
		if (useTables)
		    printf "<td>&nbsp;</td>" > OutFile
		else
		    printf ".." Dots[ind]  > OutFile
	}
	if (useTables)
	    printf "</tr>" > OutFile
	print "" > OutFile
    }
    print useTables ? "</table>" : "</pre>" > OutFile
#    if (useTables)
#	print "</center>" > OutFile
}

function GetInitLetters(Users,Count,  i,last,l,s) {
    for (i = 1; i <= Count; i++)
	if ((l = substr(Users[i],1,1)) != last) {
	    s = s "[<a href=#" l ">" l "</a>]"
	    last = l
	}
    return s
}

function DoOne(Letters,  FileType,User1,User2,l,last,Lines,First) {
    printf \
"<title>%s users with %ss</title><p>\n"\
"</head><body>\n"\
"<h1>%s users with %ss (current count: %d)</h1><p>\n"\
"<h2>Select a user whose %s you wish to read.\n"\
"</h2>\n",
    HostName,FileType = TypeNames[IndToDo],
    HostName,FileType,GoodCt,FileType > OutFile

    # Print two columns, sorted down first column and then down second column
    Lines = int((GoodCt+1) / 2)
    if (Letters != "") {
	print Letters "\n" > OutFile
	for (i = 1; i <= GoodCt; i++)
	    if ((l = substr(Users[i],1,1)) != last) {
		First[i]
		last = l
	    }
    }
    if (useTables)
	print \
"<table border=1 cellspacing=0 cellpadding=2>\n"\
"<tr><th>User</th><th>Name</th><th width=5%></th><th>User</th><th>Name</th></tr>" > OutFile
    else
	print "<pre>" > OutFile
    for (i = 1; i <= Lines; i++) {
	User1 = Users[i]
	User2 = Users[i+Lines]
	if (useTables)
	    printf "<tr>" > OutFile
	# Must do the separately because MakeField() has side effects
	printf "%s",MakeField(User1,Names[User1],HostName,MaxLen,
	i in First) > OutFile
	if (useTables)
	    print "<td></td>" > OutFile
	else
	    printf " " > OutFile
	printf "%s",MakeField(User2,Names[User2],HostName,0,
	(i+Lines) in First) > OutFile
	if (useTables)
	    print "</tr>" > OutFile
	else
	    print "" > OutFile
    }
    print useTables ? "</table>" : "</pre>" > OutFile
}

function TypeInfo(Index,BadFiles,TestFiles,URLs,TypeNames,Info,  Elem) {
    split(Info,Elem,",")
    BadFiles[Index] = Elem[1]
    TestFiles[Index] = Elem[2]
    URLs[Index] = Elem[3]
    TypeNames[Index] = Elem[4]
    if (Debug)
	printf \
	"%s: badfile=%s testfile=%s\n   url=%s typename=\"%s\" index=%s\n",
	Index,Elem[1],Elem[2],Elem[3],Elem[4],Index > "/dev/stderr"
}

# For each name read, store user name in UsersFound[i] and real name in
# Names[User], and make username,type an index of TypesFound[]
# The line being processed has this form: username:gcos-field:file-type:file
# where file is the filename if the file is in a user's home dir, else null
# The line is split on ":"
# The file-types are finger, web, and ftp
function ProcLine(multiDirs,  User) {
    User = $1
    if (NF == 4) {
	if ((User,$3) in BadUsers) {
	    if (Debug)
		printf "Found %s in %s baduser list; skipping\n",User,$3 \
		> "/dev/stderr"
	    return
	}
	if (!multiDirs && $4 != "") {
	    if ($4 in filesFound) {
		if (Debug)
		printf "Already found %s (for user %s); skipping for user %s\n",
		$4,filesFound[$4],User > "/dev/stderr"
		return
	    }
	    else
		filesFound[$4] = User
	}
	TypesFound[User,$3]
    }
    if (!(User in UsersFound))
	UsersFound[User]
    Name = $2
    sub(",.*","",Name)	# Get rid of office/phone # part of GCOS field
    if (length(Name) > MaxLen)
	Name = substr(Name,1,MaxLen-1) ">"
    Names[User] = Name
}

# Return n spaces
function Spaces(n) {
    return substr("                      ",1,n)
}

# Convert User, Name, Hostname into a selectable field.
# MaxLen is the maximum length that Name is allowed to be.
# If it is zero, no end padding is done.
function MakeField(User,Name,HostName,MaxLen,First,  EndPad,NameField) {
    # Generate padding directly instead of using %<n>s because non-printing
    # html code would produce incorrect results
    # %*s makes my awk core dump

    if (First)
	NameField = "name=" substr(User,1,1) " "
    if (MaxLen)
	EndPad = MaxLen-length(Name)
    if (User == "")
	return ""
    else
	if (useTables)
	    return \
	    sprintf("<td><a %shref=" URLs[IndToDo] ">%s</td><td>%s</a></td>",
	    NameField,User,User,Name)
	else
	    return sprintf("%s<a %shref=" URLs[IndToDo] ">%s %s</a>%s",
	    Spaces(8-length(User)),NameField,User,User,Name,Spaces(EndPad))
}

# @(#) CmdReadLine 95/09/04
# Run Command, read a single line of output from it, then close it.
# If Verbose is true, a complaint is issued if the read fails.
# Output is returned in $*
# The return value from getline is returned.  It will be 1 on a successful
# read; 0 if no lines were read due because the command produced no output
# or could not be run.  ERRNO is never set since pipes are run by a shell.
function CmdReadLine(Command,Verbose,  ret) {
    if (Debug) {
	print "* Issuing command: " Command "\n"\
	      "* Waiting for single line of output..." > "/dev/stderr"
    }
    ret = Command | getline
    if (Verbose && ret != 1)
	printf "Read from pipe '%s' failed\n",Command
    # close doesn't return a value under awk, only gawk
    close(Command)
    if (Debug)
	print "* Output: " $0 > "/dev/stderr"
    return ret
}

### Begin qsort routines

# Arr[] is an array of values with arbitrary indices.
# k[] is returned with numeric indices 1..n.
# The values in k[] are the indices of Arr[],
# ordered so that if Arr[] is stepped through
# in the order Arr[k[1]] .. Arr[k[n]], it will be stepped
# through in order of the values of its elements.
# The return value is the number of elements in the arrays (n).
function qsortArbIndByValue(Arr,k,  ArrInd,ElNum) {
    ElNum = 0
    for (ArrInd in Arr)
	k[++ElNum] = ArrInd
    qsortSegment(Arr,k,1,ElNum)
    return ElNum
}

# Sort a segment of an array.
# Arr[] contains data with arbitrary indices.
# k[] has indices 1..nelem, with the indices of arr[] as values.
# This function sorts the elements of arr that are pointed to by
# k[start..end], swapping the values of elements of k[] so that
# when this function returns arr[k[start..end]] will be in order.
function qsortSegment(Arr,k,start,end,  left,right,sepval,tmp,tmpe,tmps) {
    # handle two-element case explicitely for a tiny speedup
    if ((end - start) == 1) {
	if (Arr[tmps = k[start]] > Arr[tmpe = k[end]]) {
	    k[start] = tmpe
	    k[end] = tmps
	}
	return
    }
    # Make sure comparisons act on these as numbers
    left = start+0
    right = end+0
    sepval = Arr[k[int((left + right) / 2)]]
    # Make every element <= sepval be to the left of every element > sepval
    while (left < right) {
	while (Arr[k[left]] < sepval)
	    left++
	while (Arr[k[right]] > sepval)
	    right--
	if (left < right) {
	    tmp = k[left]
	    k[left++] = k[right]
	    k[right--] = tmp
	}
    }
    if (left == right)
	if (Arr[k[left]] < sepval)
	    left++
	else
	    right--
    if (start < right)
	qsortSegment(Arr,k,start,right)
    if (left < end)
	qsortSegment(Arr,k,left,end)
}

# Arr[] is an array of values with arbitrary indices.
# k[] is returned with numeric indices 1..n.
# The values in k are the indices of Arr[],
# ordered so that if Arr[] is stepped through
# in the order Arr[k[1]] .. Arr[k[n]], it will be stepped
# through in order of the values of its indices.
# The return value is the number of elements in the arrays (n).
# If the indexes are numeric, Numeric should be true, so that they can be
# compared as such rather than as strings.  Numeric indexes do not have to be
# contiguous.
function qsortByArbIndex(Arr,k,Numeric,  ArrInd,ElNum) {
    ElNum = 0
    if (Numeric)
	# Indexes do not preserve numeric type, so must be forced
	for (ArrInd in Arr)
	    k[++ElNum] = ArrInd+0
    else
	for (ArrInd in Arr)
	    k[++ElNum] = ArrInd
    qsortNumIndByValue(k,1,ElNum)
    return ElNum
}

# Arr is an array of elements with contiguous numeric indexes to be sorted
# by value.
# start and end are the starting and ending indexes of the range to be sorted.
function qsortNumIndByValue(Arr,start,end,  left,right,sepval,tmp,tmpe,tmps) {
    # handle two-element case explicitely for a tiny speedup
    if ((start - end) == 1) {
	if ((tmps = Arr[start]) > (tmpe = Arr[end])) {
	    Arr[start] = tmpe
	    Arr[end] = tmps
	}
	return
    }
    left = start+0
    right = end+0
    sepval = Arr[int((left + right) / 2)]
    while (left < right) {
	while (Arr[left] < sepval)
	    left++
	while (Arr[right] > sepval)
	    right--
	if (left <= right) {
	    tmp = Arr[left]
	    Arr[left++] = Arr[right]
	    Arr[right--] = tmp
	}
    }
    if (start < right)
	qsortNumIndByValue(Arr,start,right)
    if (left < end)
	qsortNumIndByValue(Arr,left,end)
}

### End qsort routines
### Start of ProcArgs library
# @(#) ProcArgs 1.12 97/05/26
# 92/02/29 john h. dubois iii (john@armory.com)
# 93/07/18 Added "#" arg type
# 93/09/26 Do not count h option against MinArgs
# 94/01/01 Stop scanning at first non-option arg.  Added ">" option type.
#          Removed meaning of "+" or "-" by itself.
# 94/03/08 Added & option and *()< option types.
# 94/04/02 Added NoRCopt to Opts()
# 94/06/11 Mark numeric variables as such.
# 94/07/08 Opts(): Do not require any args if h option is given.
# 95/01/22 Record options given more than once.  Record option num in argv.
# 95/06/08 Added ExclusiveOptions().
# 96/01/20 Let rcfiles be a colon-separated list of filenames.
#          Expand $VARNAME at the start of its filenames.
#          Let varname=0 and [-+]option- turn off an option.
# 96/05/05 Changed meaning of 7th arg to Opts; now can specify exactly how many
#          of the vars should be searched for in the environment.
#          Check for duplicate rcfiles.
# 96/05/13 Return more specific error values.  Note: ProcArgs() and InitOpts()
#          now return various negatives values on error, not just -1, and
#          Opts() may set Err to various positive values, not just 1.
#          Added AllowUnrecOpt.
# 96/05/23 Check type given for & option
# 96/06/15 Re-port to awk
# 96/10/01 Moved file-reading code into ReadConfFile(), so that it can be
#          used by other functions.
# 96/10/15 Added OptChars
# 96/11/01 Added exOpts arg to Opts()
# 96/11/16 Added ; type
# 96/12/08 Added Opt2Set() & Opt2Sets()
# 96/12/27 Added CmdLineOpt()
# 97/02/22 Remove packed elements.
# 97/02/28 Make sequence # for rcfiles & environ be "f" and "e".
#          Replaced CmdLineOpt() with OptsGiven().
# 97/05/26 Added mangleHelp().

# optlist is a string which contains all of the possible command line options.
# A character followed by certain characters indicates that the option takes
# an argument, with type as follows:
# :	String argument
# ;	Non-empty string argument
# *	Floating point argument
# (	Non-negative floating point argument
# )	Positive floating point argument
# #	Integer argument
# <	Non-negative integer argument
# >	Positive integer argument
# The only difference the type of argument makes is in the runtime argument
# error checking that is done.

# The & option is a special case used to get numeric options without the
# user having to give an option character.  It is shorthand for [-+.0-9].
# If & is included in optlist and an option string that begins with one of
# these characters is seen, the value given to "&" will include the first
# char of the option.  & must be followed by a type character other than ":"
# or ";".
# Note that if e.g. &> is given, an option of -.5 will produce an error.

# Strings in argv[] which begin with "-" or "+" are taken to be
# strings of options, except that a string which consists solely of "-"
# or "+" is taken to be a non-option string; like other non-option strings,
# it stops the scanning of argv and is left in argv[].
# An argument of "--" or "++" also stops the scanning of argv[] but is removed.
# If an option takes an argument, the argument may either immediately
# follow it or be given separately.
# "-" and "+" options are treated the same.  "+" is allowed because most awks
# take any -options to be arguments to themselves.  gawk 2.15 was enhanced to
# stop scanning when it encounters an unrecognized option, though until 2.15.5
# this feature had a flaw that caused problems in some cases.  See the OptChars
# parameter to explicitly set the option-specifier characters.

# If an option that does not take an argument is given,
# an index with its name is created in Options and its value is set to the
# number of times it occurs in argv[].

# If an option that does take an argument is given, an index with its name is
# created in Options and its value is set to the value of the argument given
# for it, and Options[option-name,"count"] is (initially) set to the 1.
# If an option that takes an argument is given more than once,
# Options[option-name,"count"] is incremented, and the value is assigned to
# the index (option-name,instance) where instance is 2 for the second occurance
# of the option, etc.
# In other words, the first time an option with a value is encountered, the
# value is assigned to an index consisting only of its name; for any further
# occurances of the option, the value index has an extra (count) dimension.

# The sequence number for each option found in argv[] is stored in
# Options[option-name,"num",instance], where instance is 1 for the first
# occurance of the option, etc.  The sequence number starts at 1 and is
# incremented for each option, both those that have a value and those that
# do not.  Options set from a config file get a sequence number of "f", and
# options set in the environment get a sequence number of "e".

# Options and their arguments are deleted from argv.
# Note that this means that there may be gaps left in the indices of argv[].
# If compress is nonzero, argv[] is packed by moving its elements so that
# they have contiguous integer indices starting with 0.
# Option processing will stop with the first unrecognized option, just as
# though -- or ++ was given except that the unrecognized option will not be
# removed from ARGV[].  Normally, an error value is returned in this case.
# If AllowUnrecOpt is true, it is not an error for an unrecognized option to
# be found, so the number of remaining arguments is returned instead.
# If OptChars is not a null string, it is the set of characters that indicate
# that an argument is an option string if the string begins with one of the
# characters.  A string consisting solely of two of the same option-indicator
# characters stops the scanning of argv[].  The default is "-+".
# argv[0] is not examined.
# The number of arguments left in argc is returned.
# If an error occurs, the global string OptErr is set to an error message
# and a negative value is returned.
# Current error values:
# -1: option that required an argument did not get it.
# -2: argument of incorrect type supplied for an option.
# -3: unrecognized (invalid) option.
function ProcArgs(argc,argv,OptList,Options,compress,AllowUnrecOpt,OptChars,
ArgNum,ArgsLeft,Arg,ArgLen,ArgInd,Option,Pos,NumOpt,Value,HadValue,specGiven,
NeedNextOpt,GotValue,OptionNum,Escape,dest,src,count,c,OptTerm,OptCharSet)
{
# ArgNum is the index of the argument being processed.
# ArgsLeft is the number of arguments left in argv.
# Arg is the argument being processed.
# ArgLen is the length of the argument being processed.
# ArgInd is the position of the character in Arg being processed.
# Option is the character in Arg being processed.
# Pos is the position in OptList of the option being processed.
# NumOpt is true if a numeric option may be given.
    ArgsLeft = argc
    NumOpt = index(OptList,"&")
    OptionNum = 0
    if (OptChars == "")
	OptChars = "-+"
    while (OptChars != "") {
	c = substr(OptChars,1,1)
	OptChars = substr(OptChars,2)
	OptCharSet[c]
	OptTerm[c c]
    }
    for (ArgNum = 1; ArgNum < argc; ArgNum++) {
	Arg = argv[ArgNum]
	if (length(Arg) < 2 || !((specGiven = substr(Arg,1,1)) in OptCharSet))
	    break	# Not an option; quit
	if (Arg in OptTerm) {
	    delete argv[ArgNum]
	    ArgsLeft--
	    break
	}
	ArgLen = length(Arg)
	for (ArgInd = 2; ArgInd <= ArgLen; ArgInd++) {
	    Option = substr(Arg,ArgInd,1)
	    if (NumOpt && Option ~ /[-+.0-9]/) {
		# If this option is a numeric option, make its flag be & and
		# its option string flag position be the position of & in
		# the option string.
		Option = "&"
		Pos = NumOpt
		# Prefix Arg with a char so that ArgInd will point to the
		# first char of the numeric option.
		Arg = "&" Arg
		ArgLen++
	    }
	    # Find position of flag in option string, to get its type (if any).
	    # Disallow & as literal flag.
	    else if (!(Pos = index(OptList,Option)) || Option == "&") {
		if (AllowUnrecOpt) {
		    Escape = 1
		    break
		}
		else {
		    OptErr = "Invalid option: " specGiven Option
		    return -3
		}
	    }

	    # Find what the value of the option will be if it takes one.
	    # NeedNextOpt is true if the option specifier is the last char of
	    # this arg, which means that if the option requires a value it is
	    # the next arg.
	    if (NeedNextOpt = (ArgInd >= ArgLen)) { # Value is the next arg
		if (GotValue = ArgNum + 1 < argc)
		    Value = argv[ArgNum+1]
	    }
	    else {	# Value is included with option
		Value = substr(Arg,ArgInd + 1)
		GotValue = 1
	    }

	    if (HadValue = AssignVal(Option,Value,Options,
	    substr(OptList,Pos + 1,1),GotValue,"",++OptionNum,!NeedNextOpt,
	    specGiven)) {
		if (HadValue < 0)	# error occured
		    return HadValue
		if (HadValue == 2)
		    ArgInd++	# Account for the single-char value we used.
		else {
		    if (NeedNextOpt) {	# option took next arg as value
			delete argv[++ArgNum]
			ArgsLeft--
		    }
		    break	# This option has been used up
		}
	    }
	}
	if (Escape)
	    break
	# Do not delete arg until after processing of it, so that if it is not
	# recognized it can be left in ARGV[].
	delete argv[ArgNum]
	ArgsLeft--
    }
    if (compress != 0) {
	dest = 1
	src = argc - ArgsLeft + 1
	if (src != dest) {
	    for (count = ArgsLeft - 1; count; count--) {
		ARGV[dest] = ARGV[src]
		dest++
		src++
	    }
	    for (; dest < src; dest++)
		delete ARGV[dest]
	}
    }
    return ArgsLeft
}

# Assignment to values in Options[] occurs only in this function.
# Option: Option specifier character.
# Value: Value to be assigned to option, if it takes a value.
# Options[]: Options array to return values in.
# ArgType: Argument type specifier character.
# GotValue: Whether any value is available to be assigned to this option.
# Name: Name of option being processed.
# OptionNum: Number of this option (starting with 1) if set in argv[],
#     or 0 if it was given in a config file or in the environment.
# SingleOpt: true if the value (if any) that is available for this option was
#     given as part of the same command line arg as the option.  Used only for
#     options from the command line.
# specGiven is the option specifier character use, if any (e.g. - or +),
# for use in error messages.
# Global variables: OptErr
# Return value: negative value on error, 0 if option did not require an
# argument, 1 if it did & used the whole arg, 2 if it required just one char of
# the arg.
# Current error values:
# -1: Option that required an argument did not get it.
# -2: Value of incorrect type supplied for option.
# -3: Bad type given for option &
function AssignVal(Option,Value,Options,ArgType,GotValue,Name,OptionNum,
SingleOpt,specGiven,  UsedValue,Err,NumTypes) {
    # If option takes a value...    [
    NumTypes = "*()#<>]"
    if (Option == "&" && ArgType !~ "[" NumTypes) {	# ]
	OptErr = "Bad type given for & option"
	return -3
    }

    if (UsedValue = (ArgType ~ "[:;" NumTypes)) {	# ]
	if (!GotValue) {
	    if (Name != "")
		OptErr = "Variable requires a value -- " Name
	    else
		OptErr = "option requires an argument -- " Option
	    return -1
	}
	if ((Err = CheckType(ArgType,Value,Option,Name,specGiven)) != "") {
	    OptErr = Err
	    return -2
	}
	# Mark this as a numeric variable; will be propogated to Options[] val.
	if (ArgType != ":" && ArgType != ";")
	    Value += 0
	if ((Instance = ++Options[Option,"count"]) > 1)
	    Options[Option,Instance] = Value
	else
	    Options[Option] = Value
    }
    # If this is an environ or rcfile assignment & it was given a value...
    else if (!OptionNum && Value != "") {
	UsedValue = 1
	# If the value is "0" or "-" and this is the first instance of it,
	# do not set Options[Option]; this allows an assignment in an rcfile to
	# turn off an option (for the simple "Option in Options" test) in such
	# a way that it cannot be turned on in a later file.
	if (!(Option in Options) && (Value == "0" || Value == "-"))
	    Instance = 1
	else
	    Instance = ++Options[Option]
	# Save the value even though this is a flag
	Options[Option,Instance] = Value
    }
    # If this is a command line flag and has a - following it in the same arg,
    # it is being turned off.
    else if (OptionNum && SingleOpt && substr(Value,1,1) == "-") {
	UsedValue = 2
	if (Option in Options)
	    Instance = ++Options[Option]
	else
	    Instance = 1
	Options[Option,Instance]
    }
    # If this is a flag assignment without a value, increment the count for the
    # flag unless it was turned off.  The indicator for a flag being turned off
    # is that the flag index has not been set in Options[] but it has an
    # instance count.
    else if (Option in Options || !((Option,1) in Options))
	# Increment number of times this flag seen; will inc null value to 1
	Instance = ++Options[Option]
    Options[Option,"num",Instance] = OptionNum
    return UsedValue
}

# Option is the option letter
# Value is the value being assigned
# Name is the var name of the option, if any
# ArgType is one of:
# :	String argument
# ;	Non-null string argument
# *	Floating point argument
# (	Non-negative floating point argument
# )	Positive floating point argument
# #	Integer argument
# <	Non-negative integer argument
# >	Positive integer argument
# specGiven is the option specifier character use, if any (e.g. - or +),
# for use in error messages.
# Returns null on success, err string on error
function CheckType(ArgType,Value,Option,Name,specGiven,  Err,ErrStr) {
    if (ArgType == ":")
	return ""
    if (ArgType == ";") {
	if (Value == "")
	    Err = "must be a non-empty string"
    }
    # A number begins with optional + or -, and is followed by a string of
    # digits or a decimal with digits before it, after it, or both
    else if (Value !~ /^[-+]?([0-9]+|[0-9]*\.[0-9]+|[0-9]+\.)$/)
	Err = "must be a number"
    else if (ArgType ~ "[#<>]" && Value ~ /\./)
	Err = "may not include a fraction"
    else if (ArgType ~ "[()<>]" && Value < 0)
	Err = "may not be negative"
    # (
    else if (ArgType ~ "[)>]" && Value == 0)
	Err = "must be a positive number"
    if (Err != "") {
	ErrStr = "Bad value \"" Value "\".  Value assigned to "
	if (Name != "")
	    return ErrStr "variable " substr(Name,1,1) " " Err
	else {
	    if (Option == "&")
		Option = Value
	    return ErrStr "option " specGiven substr(Option,1,1) " " Err
	}
    }
    else
	return ""
}

# Note: only the above functions are needed by ProcArgs.
# The rest of these functions call ProcArgs() and also do other
# option-processing stuff.

# Opts: Process command line arguments.
# Opts processes command line arguments using ProcArgs()
# and checks for errors.  If an error occurs, a message is printed
# and the program is exited.
#
# Input variables:
# Name is the name of the program, for error messages.
# Usage is a usage message, for error messages.
# OptList the option description string, as used by ProcArgs().
# MinArgs is the minimum number of non-option arguments that this
# program should have, non including ARGV[0] and +h.
# If the program does not require any non-option arguments,
# MinArgs should be omitted or given as 0.
# rcFiles, if given, is a colon-seprated list of filenames to read for
# variable initialization.  If a filename begins with ~/, the ~ is replaced
# by the value of the environment variable HOME.  If a filename begins with
# $, the part from the character after the $ up until (but not including)
# the first character not in [a-zA-Z0-9_] will be searched for in the
# environment; if found its value will be substituted, if not the filename will
# be discarded.
# rcfiles are read in the order given.
# Values given in them will not override values given on the command line,
# and values given in later files will not override those set in earlier
# files, because AssignVal() will store each with a different instance index.
# The first instance of each variable, either on the command line or in an
# rcfile, will be stored with no instance index, and this is the value
# normally used by programs that call this function.
# VarNames is a comma-separated list of variable names to map to options,
# in the same order as the options are given in OptList.
# If EnvSearch is given and nonzero, the first EnvSearch variables will also be
# searched for in the environment.  If set to -1, all values will be searched
# for in the environment.  Values given in the environment will override
# those given in the rcfiles but not those given on the command line.
# NoRCopt, if given, is an additional letter option that if given on the
# command line prevents the rcfiles and environment from being read.
# See ProcArgs() for a description of AllowUnRecOpt and optChars, and
# ExclusiveOptions() for a description of exOpts.
# Special options:
# If x is made an option and is given, some debugging info is output.
# h is assumed to be the help option.

# Global variables:
# The command line arguments are taken from ARGV[].
# The arguments that are option specifiers and values are removed from
# ARGV[], leaving only ARGV[0] and the non-option arguments.
# The number of elements in ARGV[] should be in ARGC.
# After processing, ARGC is set to the number of elements left in ARGV[].
# The option values are put in Options[].
# On error, Err is set to a positive integer value so it can be checked for in
# an END block.
# Return value: The number of elements left in ARGV is returned.
# Must keep OptErr global since it may be set by InitOpts().
function Opts(Name,Usage,OptList,MinArgs,rcFiles,VarNames,EnvSearch,NoRCopt,
AllowUnrecOpt,optChars,exOpts,  ArgsLeft,e) {
    if (MinArgs == "")
	MinArgs = 0
    ArgsLeft = ProcArgs(ARGC,ARGV,OptList NoRCopt,Options,1,AllowUnrecOpt,
    optChars)
    if (ArgsLeft < (MinArgs+1) && !("h" in Options)) {
	if (ArgsLeft >= 0) {
	    OptErr = "Not enough arguments"
	    Err = 4
	}
	else
	    Err = -ArgsLeft
	print mangleHelp(sprintf("%s: %s.\nUse -h for help.\n%s",
	Name,OptErr,Usage)," \t\n[") > "/dev/stderr"
	exit 1
    }
    if (rcFiles != "" && (NoRCopt == "" || !(NoRCopt in Options)) &&
    (e = InitOpts(rcFiles,Options,OptList,VarNames,EnvSearch)) < 0)
    {
	print Name ": " OptErr ".\nUse -h for help." > "/dev/stderr"
	Err = -e
	exit 1
    }
    if ((exOpts != "") && ((OptErr = ExclusiveOptions(exOpts,Options)) != ""))
    {
	printf "%s: Error: %s\n",Name,OptErr > "/dev/stderr"
	Err = 1
	exit 1
    }
    return ArgsLeft
}

# If this is not gawk, convert -x options in a help message to +x
# If whitespace is non-null, it is the set of characters that may precede an
# option indicator to indicate that is such.  The default is newline, space,
# or tab.
function mangleHelp(message,whitespace,  i,w) {
    if (IGNORECASE "" != "0") {
	if (whitespace == "")
	    whitespace = " \t\n"
	for (i = 1; (w = substr(whitespace,i,1)) != ""; i++)
		gsub("\\" w "-",w "+",message)
    }
    return message
}

# ReadConfFile(): Read a file containing var/value assignments, in the form
# <variable-name><assignment-char><value>.
# Whitespace (spaces and tabs) around a variable (leading whitespace on the
# line and whitespace between the variable name and the assignment character) 
# is stripped.  Lines that do not contain an assignment operator or which
# contain a null variable name are ignored, other than possibly being noted in
# the return value.  If more than one assignment is made to a variable, the
# first assignment is used.
# Input variables:
# File is the file to read.
# Comment is the line-comment character.  If it is found as the first non-
#     whitespace character on a line, the line is ignored.
# Assign is the assignment string.  The first instance of Assign on a line
#     separates the variable name from its value.
# If StripWhite is true, whitespace around the value (whitespace between the
#     assignment char and trailing whitespace on the line) is stripped.
# VarPat is a pattern that variable names must match.  
#     Example: "^[a-zA-Z][a-zA-Z0-9]+$"
# If FlagsOK is true, variables are allowed to be "set" by being put alone on
#     a line; no assignment operator is needed.  These variables are set in
#     the output array with a null value.  Lines containing nothing but
#     whitespace are still ignored.
# Output variables:
# Values[] contains the assignments, with the indexes being the variable names
#     and the values being the assigned values.
# Lines[] contains the line number that each variable occured on.  A flag set
#     is record by giving it an index in Lines[] but not in Values[].
# Return value:
# If any errors occur, a string consisting of descriptions of the errors
# separated by newlines is returned.  In no case will the string start with a
# numeric value.  If no errors occur,  the number of lines read is returned.
function ReadConfigFile(Values,Lines,File,Comment,Assign,StripWhite,VarPat,
FlagsOK,
Line,Status,Errs,AssignLen,LineNum,Var,Val) {
    if (Comment != "")
	Comment = "^" Comment
    AssignLen = length(Assign)
    if (VarPat == "")
	VarPat = "."	# null varname not allowed
    while ((Status = (getline Line < File)) == 1) {
	LineNum++
	sub("^[ \t]+","",Line)
	if (Line == "")		# blank line
	    continue
	if (Comment != "" && Line ~ Comment)
	    continue
	if (Pos = index(Line,Assign)) {
	    Var = substr(Line,1,Pos-1)
	    Val = substr(Line,Pos+AssignLen)
	    if (StripWhite) {
		sub("^[ \t]+","",Val)
		sub("[ \t]+$","",Val)
	    }
	}
	else {
	    Var = Line	# If no value, var is entire line
	    Val = ""
	}
	if (!FlagsOK && Val == "") {
	    Errs = Errs \
	    sprintf("\nBad assignment on line %d of file %s: %s",
	    LineNum,File,Line)
	    continue
	}
	sub("[ \t]+$","",Var)
	if (Var !~ VarPat) {
	    Errs = Errs sprintf("\nBad variable name on line %d of file %s: %s",
	    LineNum,File,Var)
	    continue
	}
	if (!(Var in Lines)) {
	    Lines[Var] = LineNum
	    if (Pos)
		Values[Var] = Val
	}
    }
    if (Status)
	Errs = Errs "\nCould not read file " File
    close(File)
    return Errs == "" ? LineNum : substr(Errs,2)	# Skip first newline
}

# Variables:
# Data is stored in Options[].
# rcFiles, OptList, VarNames, and EnvSearch are as as described for Opts().
# Global vars:
# Sets OptErr.  Uses ENVIRON[].
# If anything is read from any of the rcfiles, sets READ_RCFILE to 1.
function InitOpts(rcFiles,Options,OptList,VarNames,EnvSearch,
Line,Var,Pos,Vars,Map,CharOpt,NumVars,TypesInd,Types,Type,Ret,i,rcFile,
fNames,numrcFiles,filesRead,Err,Values,retStr) {
    split("",filesRead,"")	# make awk know this is an array
    NumVars = split(VarNames,Vars,",")
    TypesInd = Ret = 0
    if (EnvSearch == -1)
	EnvSearch = NumVars
    for (i = 1; i <= NumVars; i++) {
	Var = Vars[i]
	CharOpt = substr(OptList,++TypesInd,1)
	if (CharOpt ~ "^[:;*()#<>&]$")
	    CharOpt = substr(OptList,++TypesInd,1)
	Map[Var] = CharOpt
	Types[Var] = Type = substr(OptList,TypesInd+1,1)
	# Do not overwrite entries from environment
	if (i <= EnvSearch && Var in ENVIRON &&
	(Err = AssignVal(CharOpt,ENVIRON[Var],Options,Type,1,Var,"e")) < 0)
	    return Err
    }

    numrcFiles = split(rcFiles,fNames,":")
    for (i = 1; i <= numrcFiles; i++) {
	rcFile = fNames[i]
	if (rcFile ~ "^~/")
	    rcFile = ENVIRON["HOME"] substr(rcFile,2)
	else if (rcFile ~ /^\$/) {
	    rcFile = substr(rcFile,2)
	    match(rcFile,"^[a-zA-Z0-9_]*")
	    envvar = substr(rcFile,1,RLENGTH)
	    if (envvar in ENVIRON)
		rcFile = ENVIRON[envvar] substr(rcFile,RLENGTH+1)
	    else
		continue
	}
	if (rcFile in filesRead)
	    continue
	# rcfiles are liable to be given more than once, e.g. UHOME and HOME
	# may be the same
	filesRead[rcFile]
	if ("x" in Options)
	    printf "Reading configuration file %s\n",rcFile > "/dev/stderr"
	retStr = ReadConfigFile(Values,Lines,rcFile,"#","=",0,"",1)
	if (retStr > 0)
	    READ_RCFILE = 1
	else if (ret != "") {
	    OptErr = retStr
	    Ret = -1
	}
	for (Var in Lines)
	    if (Var in Map) {
		if ((Err = AssignVal(Map[Var],Var in Values ? Values[Var] : "",
		Options,Types[Var],Var in Values,Var,"f")) < 0)
		    return Err
	    }
	    else {
		OptErr = sprintf(\
		"Unknown var \"%s\" assigned to on line %d\nof file %s",Var,
		Lines[Var],rcFile)
		Ret = -1
	    }
    }

    if ("x" in Options)
	for (Var in Map)
	    if (Map[Var] in Options)
		printf "(%s) %s=%s\n",Map[Var],Var,Options[Map[Var]] > \
		"/dev/stderr"
	    else
		printf "(%s) %s not set\n",Map[Var],Var > "/dev/stderr"
    return Ret
}

# OptSets is a semicolon-separated list of sets of option sets.
# Within a list of option sets, the option sets are separated by commas.  For
# each set of sets, if any option in one of the sets is in Options[] AND any
# option in one of the other sets is in Options[], an error string is returned.
# If no conflicts are found, nothing is returned.
# Example: if OptSets = "ab,def,g;i,j", an error will be returned due to
# the exclusions presented by the first set of sets (ab,def,g) if:
# (a or b is in Options[]) AND (d, e, or f is in Options[]) OR
# (a or b is in Options[]) AND (g is in Options) OR
# (d, e, or f is in Options[]) AND (g is in Options)
# An error will be returned due to the exclusions presented by the second set
# of sets (i,j) if: (i is in Options[]) AND (j is in Options[]).
# todo: make options given on command line unset options given in config file
# todo: that they conflict with.
function ExclusiveOptions(OptSets,Options,
Sets,SetSet,NumSets,Pos1,Pos2,Len,s1,s2,c1,c2,ErrStr,L1,L2,SetSets,NumSetSets,
SetNum,OSetNum) {
    NumSetSets = split(OptSets,SetSets,";")
    # For each set of sets...
    for (SetSet = 1; SetSet <= NumSetSets; SetSet++) {
	# NumSets is the number of sets in this set of sets.
	NumSets = split(SetSets[SetSet],Sets,",")
	# For each set in a set of sets except the last...
	for (SetNum = 1; SetNum < NumSets; SetNum++) {
	    s1 = Sets[SetNum]
	    L1 = length(s1)
	    for (Pos1 = 1; Pos1 <= L1; Pos1++)
		# If any of the options in this set was given, check whether
		# any of the options in the other sets was given.  Only check
		# later sets since earlier sets will have already been checked
		# against this set.
		if ((c1 = substr(s1,Pos1,1)) in Options)
		    for (OSetNum = SetNum+1; OSetNum <= NumSets; OSetNum++) {
			s2 = Sets[OSetNum]
			L2 = length(s2)
			for (Pos2 = 1; Pos2 <= L2; Pos2++)
			    if ((c2 = substr(s2,Pos2,1)) in Options)
				ErrStr = ErrStr "\n"\
				sprintf("Cannot give both %s and %s options.",
				c1,c2)
		    }
	}
    }
    if (ErrStr != "")
	return substr(ErrStr,2)
    return ""
}

# The value of each instance of option Opt that occurs in Options[] is made an
# index of Set[].
# The return value is the number of instances of Opt in Options.
function Opt2Set(Options,Opt,Set,  count) {
    if (!(Opt in Options))
	return 0
    Set[Options[Opt]]
    count = Options[Opt,"count"]
    for (; count > 1; count--)
	Set[Options[Opt,count]]
    return count
}

# The value of each instance of option Opt that occurs in Options[] that
# begins with "!" is made an index of nSet[] (with the ! stripped from it).
# Other values are made indexes of Set[].
# The return value is the number of instances of Opt in Options.
function Opt2Sets(Options,Opt,Set,nSet,  count,aSet,ret) {
    ret = Opt2Set(Options,Opt,aSet)
    for (value in aSet)
	if (substr(value,1,1) == "!")
	    nSet[substr(value,2)]
	else
	    Set[value]
    return ret
}

# Returns true if any option in the string Opts was given, as indicated by the
# data in Options[]. If any of Arg, Env, or File are true, the given opts are
# only considered to have been set if they were set in the command line
# arguments, environment, or in a configuration file, respectively. 
function OptsGiven(Options,Opts,Arg,Env,File,  l,i,Opt,j,c) {
    if (!Arg && !Env && !File)
	Arg = Env = File = 1
    l = length(Opts)
    for (i = 1; i <= l; i++) {
	Opt = substr(Opts,i,1)
	for (j = 1; (Opt,"num",j) in Options; j++) {
	    c = Options[Opt,"num",j]
	    if (Arg && c+0 > 0 || File && c == "f" || Env && c == "e")
		return 1
	}
    }
    return 0
}
### End of ProcArgs library

# Rename this to strftime if using non-GNU awk
# Only works for current time... does *not* take a systime argument!
function _strftime(Format,  Time) {
    "date \"+" Format "\"" | getline Time
    return Time
}

### Begin epochdays routines.
# These functions operate on epoch days and epoch months, which have the same 0
# time as UNIX epoch seconds.  These functions are mainly used to avoid having
# to deal with timezone issues.
# @(#) epochdays 1.1 95/08/26

# YMD2day(year,month,day-of-month) returns the number of days that passed from 
# 1970 Jan 1 to the given date.
# All parameters should be given in numeric form.
# If year < 70, it is assumed to be part of the 2000 century
# If year in (70..99), it is assumed to be part of the 1900 century.
# Globals: sets and uses MDays[]
function YMD2day(Year,Month,Day,   LeapDays) {
    Year+=0
    Month+=0
    if (Year < 70)
	Year += 100
    else if (Year >= 100)
	Year -= 1900
    # Year is now the number of years since 1900.
    LeapDays = int((Year - 68) / 4)
    if (Month <= 2 && Year % 4 == 0)
	LeapDays -= 1
    if (!(0 in MDays))
	split("0 31 59 90 120 151 181 212 243 273 304 334 365",MDays," ")
    return (Year - 70) * 365 + MDays[Month] + Day - 1 + LeapDays
}

# date2day("yy/mm/dd") returns the number of days that passed from 
# 1970 Jan 1 to the given date.  -1 is returned on error.
# The fields are returned in Fields: year in Fields[1], month in Fields[2],
# and day (if given) in Fields[3].
function date2day(Date,Fields,  Num,Year,Month) {
    Num = split(Date,Fields,"/")
    if (Num != 2 && Num != 3)
	return -1
    if (!(Year = Fields[1] + 0) || !(Month = Fields[2] + 0))
	return -1
    if (Num == 3)
	Day = Fields[3]
    return YMD2day(Year,Month,Day)
}

# diffdays(year1,month1,day-of-month1,year2,month2,day-of-month2)
# returns the number of complete days that passed from date 1 to date 2
function diffdays(year1,month1,day1,year2,month2,day2) {
    return YMD2day(year2,month2,day2) - YMD2day(year1,month1,day1)
}

# Given an epoch month, return the first day of that month
function month2day(Month) {
    return YMD2day(int(Month/12) + 1970,Month % 12 + 1,1)
}

# Given an epoch day, returns epoch month
function day2month(Day,  Date) {
    day2YMD(Day,Date)
    return (Date["y"]-1970)*12 + Date["m"]-1
}

# Given an epoch month, returns the number of days in that month.
function monthdays(month,  year) {
    if (!(0 in MDur))
	split("31 28 31 30 31 30 31 31 30 31 30 31",MDur)
    year = int(month/12)
    month = month%12+1
    return (!((year+2)%4) && month == 2) ? 29 : MDur[month]
}

# Given an epoch day (day since 1970 Jan 1; day 0 = 1970 Jan 1, etc.), 
# returns the date elements in Date:
# Date["y"] = year (4 digits), Date["m"] = month (jan = 1, etc.),
# Date["d"] = day of month.
# Globals: Sets/uses MDays[].
function day2YMD(Day,Date,  QYears,Year,NonLeapYears,Month) {
    if (!(0 in LDays)) {
	split("0 31 59 90 120 151 181 212 243 273 304 334 365",MDays," ")
	split("0 31 60 91 121 152 182 213 244 274 305 335 366",LDays," ")
    }
    Day += 365
    # Day is now # of days since Jan 1 1969.  1968 was a leap year.
    QYears = int(Day / (365*4+1))
    Year = 1969 + QYears * 4
    Day -= QYears * (365*4+1)
    # Day now contains no complete leap years.
    Year += NonLeapYears = int(Day/365)
    Leap = !(Year % 4)
    Day -= NonLeapYears * 365
    # Day now contains the day of year.
    # Find the month.  Divide day by 32 to get either the correct month or
    # the month prior to it.
    Month = int(Day++ / 32) + 1
    if (Day > (Leap ? LDays[Month+1] : MDays[Month+1]))
	Month++
    Day -= Leap ? LDays[Month] : MDays[Month]
    Date["d"] = Day
    Date["m"] = Month
    Date["y"] = Year
}

# Given a month number, return a date in the form yy/mm
function month2date(MonthNum) {
    return sprintf("%02d/%02d",(MonthNum / 12 + 70) % 100, MonthNum % 12 + 1)
}

# Given a day number, return a date in the form yy/mm/dd or yyyy/mm/dd
# If century is true, the century is included as part of the year;
# otherwise it is stripped.
function day2date(day,century,  year,Date) {
    day2YMD(day,Date)
    year = Date["y"]
    if (!century)
	year %= 100
    return sprintf("%02d/%02d/%02d",year,Date["m"],Date["d"])
}

# strftime_gmt: This function exists because gawk strftime() has no means of
# setting timezone (changes to ENVIRON["TZ"] do not affect gawk's real
# environment).  This function expands a few of the %descriptors that strftime
# does.  The timezone is always taken to be GMT.
# Globals:
# Sets and uses _weekdayNames[], _monthNames[]
function strftime_gmt(format,time,  day,Date,len,i,c,s) {
    if (!(1 in _weekdayNames)) {
	split("Mon|Tue|Wed|Thu|Fri|Sat|Sun",_weekdayNames,"|")
	split("Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec",_monthNames,",")
    }
    sec = time % 60
    time = int(time/60)
    min = time % 60
    time = int(time/60)
    hour = time % 24
    day = int(time/24)
    day2YMD(day,Date)
    len = length(format)
    for (i = 1; i <= len; i++)
	if ((c = substr(format,i,1)) == "%") {
	    i += 1
	    c = substr(format,i,1)
	    if (c == "a")	# Short weekday name
		o = _weekdayNames[(day+3) % 7 + 1]
	    else if (c == "d")	# Day of month
		o = sprintf("%02d",Date["d"])
	    else if (c == "b")	# Short month name
		o = _monthNames[Date["m"]+0]
	    else if (c == "Y")	# 4-digit year
		o = Date["y"]
	    else if (c == "T")	# Time, as hh:mm:ss
		o = sprintf("%02d:%02d:%02d",hour,min,sec)
	    else
		o = c
	    s = s o
	}
	else
	    s = s c
	return s
}
### End epochdays routines
